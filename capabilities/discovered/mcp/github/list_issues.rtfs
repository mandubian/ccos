;; MCP Capability: list_issues
;; Generated from MCP tool introspection
;; MCP Server: github (https://api.githubcopilot.com/mcp/)
;; Tool: list_issues

;; Sample Output:
;; {
;;   "content": [
;;     {
;;       "text": "{\"issues\":[{\"id\":3626081784,\"number\":164,\"state\":\"OPEN\",\"title\":\"Ensure storage/archives complement, not replace, the CausalChain\",\"body\":\"## Summary\\n\\nCCOS introduces several storage and archive modules (`storage`, `storage_backends`, `intent_archive`, `plan_archive`, `checkpoint_archive`, `wm_integration`, etc.) alongside `causal_chain`. The Causal Chain is intended to be the canonical audit trail / memory, while archives and storage provide conventional persistence.\\n\\nThis issue tracks reviewing storage modules to ensure they **complement** the Causal Chain and do not act as implicit, ungoverned histories for important actions.\\n\\n## Motivation\\n\\n- **Single source of truth for history:** The Causal Chain should be the place to look for \\u0026#34;what happened\\u0026#34; and \\u0026#34;why\\u0026#34;. Archives and storage should hang off that, not compete with it.\\n- **Consistency with architecture:** Docs describe Plan/Intent archives as backing stores referenced from the chain, not alternate event logs.\\n- **Future tooling:** Analysis, visualization, and replay tooling will be simpler if the chain is the canonical event stream.\\n\\n## Tasks\\n\\n1. **Inventory storage and archive modules**\\n   - List responsibilities of `intent_archive`, `plan_archive`, `checkpoint_archive`, `storage`, `storage_backends`, `wm_integration`, and any other stateful modules in `ccos`.\\n\\n2. **Map storage writes to CausalChain events**\\n   - For each class of write (e.g., new intent stored, plan archived, checkpoint saved, WM update):\\n     - identify whether there is an associated Causal Chain event,\\n     - if not, decide whether one should exist.\\n\\n3. **Add missing CausalChain events where needed**\\n   - When a storage write represents a semantically meaningful event (e.g., plan approved/executed, checkpoint representing an externally visible state, WM update that shapes behavior), add a corresponding `CausalChain` entry.\\n\\n4. **Document the relationship**\\n   - Write a short doc or code comments clarifying:\\n     - which histories live in CausalChain vs. archives,\\n     - how to navigate from a chain event to its underlying stored data.\\n\\n## Acceptance Criteria\\n\\n- For each major storage/archival operation, there is a clear answer to \\u0026#34;is there a CausalChain event for this?\\u0026#34; and \\u0026#34;how do we get from the event to the stored record?\\u0026#34;.\\n- No module relies solely on its own tables/files as a history of user-visible or governance-relevant events.\\n- At least brief documentation exists summarizing how CausalChain and storage/archives interrelate.\\n\\n## Related Issues\\n\\n- #162 Bring CausalChain up to date with current CCOS runtime and storage modules\\n- #161 Audit Orchestrator entrypoints to ensure all execution goes through GovernanceKernel\\n\",\"user\":{\"login\":\"mandubian\"},\"labels\":[{\"name\":\"storage\",\"description\":\"\",\"node_id\":\"LA_kwDOOvgshs8AAAACG86Lpw\"},{\"name\":\"causal-chain\",\"description\":\"\",\"node_id\":\"LA_kwDOOvgshs8AAAACH54nDg\"},{\"name\":\"governance-kernel-review\",\"description\":\"\",\"node_id\":\"LA_kwDOOvgshs8AAAACPv_PoQ\"}],\"comments\":0,\"created_at\":\"2025-11-14T15:26:36Z\",\"updated_at\":\"2025-11-14T15:26:36Z\"}],\"pageInfo\":{\"endCursor\":\"Y3Vyc29yOnYyOpK5MjAyNS0xMS0xNFQxNjoyNjozNiswMTowMM7YIZ34\",\"hasNextPage\":true,\"hasPreviousPage\":false,\"startCursor\":\"Y3Vyc29yOnYyOpK5MjAyNS0xMS0xNFQxNjoyNjozNiswMTowMM7YIZ34\"},\"totalCount\":136}",
;;       "type": "text"
;;     }
;;   ]
;; }


(capability "mcp.github.list_issues"
  :name "list_issues"
  :version "1.0.0"
  :description "List issues in a GitHub repository. For pagination, use the 'endCursor' from the previous response's 'pageInfo' in the 'after' parameter."
  :provider "MCP"
  :provider-meta {
    :server_url "https://api.githubcopilot.com/mcp/"
    :tool_name "list_issues"
    :requires_session "auto"
    :auth_env_var "MCP_AUTH_TOKEN"
  }
  :permissions [:network.http]
  :effects [:network_request :mcp_call]
  :metadata {
    :mcp {
      :server_url "https://api.githubcopilot.com/mcp/"
      :server_name "github"
      :tool_name "list_issues"
      :protocol_version "2024-11-05"
      :requires_session "auto"
      :auth_env_var "MCP_AUTH_TOKEN"
      :mcp_auth_env_var "MCP_AUTH_TOKEN"
      :server_url_override_env "MCP_SERVER_URL"
      :mcp_server_url_override_env "MCP_SERVER_URL"
    }
    :discovery {
      :method "mcp_introspection"
      :source_url "https://api.githubcopilot.com/mcp/"
      :created_at "2025-11-18T10:58:31.255282414+00:00"
      :capability_type "mcp_tool"
    }
  }
  :input-schema [:map [:owner :string] [:repo :string]]
  :output-schema [:map [:content [:vector [:map [:text :string] [:type :string]]]]]
  :implementation
    (fn [input]
  ;; MCP Tool: List issues in a GitHub repository. For pagination, use the 'endCursor' from the previous response's 'pageInfo' in the 'after' parameter.
  ;; Runtime validates input against input_schema and output_schema
  ;; Makes standard MCP JSON-RPC call to tools/call endpoint
  ;; 
  ;; Configuration:
  ;;   - MCP_SERVER_URL: Override server URL (default from metadata)
  ;;   - MCP_AUTH_TOKEN: Optional auth token for MCP server
  ;;
  ;; Session management is handled by the runtime based on capability metadata.
  (let [default_url "https://api.githubcopilot.com/mcp/"
        env_url (call "ccos.system.get-env" "MCP_SERVER_URL")
        mcp_url (if env_url env_url default_url)
        ;; Optional: get auth token from input or env
        auth_token (or (get input :auth-token)
                       (call "ccos.system.get-env" "MCP_AUTH_TOKEN"))
        ;; Build MCP JSON-RPC request
        mcp_request {:jsonrpc "2.0"
                      :id "mcp_call"
                      :method "tools/call"
                      :params {:name "list_issues"
                               :arguments input}}
        ;; Build headers with optional auth
        headers (if auth_token
                  {:content-type "application/json"
                    :authorization (str "Bearer " auth_token)}
                  {:content-type "application/json"})]
    ;; Make HTTP POST to MCP server
    (let [response (call "ccos.network.http-fetch"
                        :method "POST"
                        :url mcp_url
                        :headers headers
                        :body (call "ccos.data.serialize-json" mcp_request))]
      ;; Parse response and extract result
      (if (get response :body)
        (let [response_json (call "ccos.data.parse-json" (get response :body))
              result (get response_json :result)]
          ;; Return MCP tool result (runtime validates against output_schema)
          result)
        ;; Return error if no response body
        {:error "No response from MCP server" :url mcp_url}))))
)
