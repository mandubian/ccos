//! Config command - configuration management

use crate::cli::{CliContext, OutputFormat, OutputFormatter};
use crate::ops::config;
use clap::Subcommand;
use rtfs::runtime::error::RuntimeResult;

#[derive(Debug, Subcommand)]
pub enum ConfigCommand {
    /// Show current configuration
    Show {
        /// Show only a specific section
        #[arg(short, long)]
        section: Option<String>,
    },

    /// Validate configuration file
    Validate,

    /// Initialize a new configuration file
    Init {
        /// Output path for the configuration file
        #[arg(short, long, default_value = "agent_config.toml")]
        output: String,

        /// Overwrite existing file
        #[arg(short, long)]
        force: bool,
    },
}

pub async fn execute(ctx: &CliContext, command: ConfigCommand) -> RuntimeResult<()> {
    let formatter = OutputFormatter::new(ctx.output_format);

    match &command {
        ConfigCommand::Show { section } => {
            command.show_config(ctx, section.as_deref(), &formatter).await
        }
        ConfigCommand::Validate => command.validate_config(ctx, &formatter),
        ConfigCommand::Init { output, force } => {
            command.init_config(output, *force, &formatter)
        }
    }
}

impl ConfigCommand {
    async fn show_config(
        &self,
        ctx: &CliContext,
        _section: Option<&str>,
        formatter: &OutputFormatter,
    ) -> RuntimeResult<()> {
        // Use ops function to get config info
        let config_info = config::show_config(ctx.config_path.clone()).await?;

        match ctx.output_format {
            OutputFormat::Json => {
                formatter.json(&config_info);
            }
            _ => {
                formatter.section("Configuration");
                formatter.kv("Config file", &config_info.config_path);
                formatter.kv("Valid", if config_info.is_valid { "Yes" } else { "No" });

                if !config_info.warnings.is_empty() {
                    formatter.warning("Configuration warnings:");
                    for warning in &config_info.warnings {
                        formatter.list_item(warning);
                    }
                }
            }
        }

        Ok(())
    }

    fn validate_config(&self, ctx: &CliContext, formatter: &OutputFormatter) -> RuntimeResult<()> {
        ctx.status(&format!(
            "Validating configuration: {:?}",
            ctx.config_path
        ));

        let warnings = ctx.validate_config()?;

        if warnings.is_empty() {
            formatter.success("Configuration is valid");
        } else {
            formatter.success("Configuration is valid with warnings:");
            for warning in warnings {
                formatter.warning(&warning);
            }
        }

        Ok(())
    }

    fn init_config(
        &self,
        output: &str,
        force: bool,
        formatter: &OutputFormatter,
    ) -> RuntimeResult<()> {
        let path = std::path::Path::new(output);

        if path.exists() && !force {
            formatter.error(&format!(
                "File already exists: {}. Use --force to overwrite.",
                output
            ));
            return Ok(());
        }

        let template = r#"# CCOS Agent Configuration
# Generated by: ccos config init

version = "1.0"
agent_id = "my-agent"
profile = "default"

# LLM Profiles
[llm_profiles]
default = "default"

[[llm_profiles.profiles]]
name = "default"
provider = "openrouter"
model = "anthropic/claude-sonnet-4-20250514"
api_key_env = "OPENROUTER_API_KEY"

# Discovery settings
[discovery]
match_threshold = 0.65
use_embeddings = false

# Governance settings
[governance]
enabled = true
default_policy = "balanced"
max_trust_level = 5
"#;

        std::fs::write(path, template).map_err(|e| {
            rtfs::runtime::error::RuntimeError::Generic(format!(
                "Failed to write config file: {}",
                e
            ))
        })?;

        formatter.success(&format!("Created configuration file: {}", output));
        Ok(())
    }
}
