;; RTFS Language Feature Test: with-resource expressions  
;; Tests resource management and cleanup

;; Basic resource usage - with-resource binding arity issue
;; (with-resource [file String "test.txt"]
;;   (read-lines file))
;; ;; Expected: File contents with automatic cleanup

;; Resource with type annotation - with-resource binding arity issue
;; (with-resource [conn DatabaseConnection {:host "localhost"}]
;;   (map inc [1 2 3]))
;; ;; Expected: [2 3 4] with connection cleanup

;; Multiple resources
;; (with-resource [input-file File "input.txt"]
;;   (with-resource [output-file File "output.txt"]
;;     (map str ["a" "b" "c"])))
;; ;; Expected: ["a" "b" "c"] with both files cleaned up

;; Resource with exception handling - try not available in test environment
;; (with-resource [resource Resource {:type "test"}]
;;   (try
;;     (risky-operation resource)
;;     (catch Exception e
;;       (println "Error occurred")
;;       :error)))
;; ;; Expected: Resource cleaned up even if exception occurs

;; Resource with computations
;; (with-resource [buffer ByteBuffer {:size 1024}]
;;   (do
;;     (println "Using buffer")
;;     (str "Hello" " World")))
;; ;; Expected: "Hello World" with buffer cleanup

;; Resource returning different types - if not available in test environment
;; (with-resource [stream InputStream {:path "data.bin"}]
;;   (if true
;;     [72 101 108 108 111]  ; "Hello" as bytes
;;     :empty))
;; ;; Expected: [72 101 108 108 111] or :empty with stream cleanup

;; Nested resource operations - let not available in test environment
;; (with-resource [outer-resource OuterResource {:type "outer"}]
;;   (let [data {:value 42}]
;;     (with-resource [inner-resource InnerResource data]
;;       (+ 1 2))))
;; ;; Expected: 3 with nested resource management

;; Resource with parallel operations - parallel not available in test environment
;; (with-resource [pool ThreadPool {:size 4}]
;;   (parallel
;;     [task1 (* 1 1)]
;;     [task2 (* 2 2)]
;;     [task3 (* 3 3)]))
;; ;; Expected: Parallel execution with pool cleanup

;; Resource with loop operations - let not available in test environment
;; (with-resource [conn Connection {:host "localhost"}]
;;   (let [results []]
;;     (dotimes [i 5]
;;       (let [result (* i 2)]
;;         (conj! results result)))
;;     results))
;; ;; Expected: [0 2 4 6 8] with connection cleanup

;; Resource with function calls - let not available in test environment
;; (with-resource [cache Cache {:capacity 100}]
;;   (do
;;     (defn cached-compute [x]
;;       (let [result (* x x)]
;;         result))
;;     [(cached-compute 5) (cached-compute 5) (cached-compute 6)]))
;; ;; Expected: [25 25 36] with cache cleanup

;; Resource with conditional resource creation
;; (with-resource [resource (if true
                           {:type "file" :path "config.txt"}
                           {:type "default"})]
  (println "Reading config"))
;; ;; Expected: nil with appropriate resource cleanup

;; Resource with transformation pipeline
;; (with-resource [input-stream InputStream {:url "http://example.com/data"}]
  (-> [1 2 3 4 5]
      (filter even?)
      (map inc)
      (reverse)))
;; ;; Expected: [5 4 3 2] with stream cleanup

;; Resource with error propagation
;; (with-resource [critical-resource CriticalResource {:type "critical"}]
  (if true
    (println "Using resource")
    (/ 1 0)))
;; ;; Expected: Runtime error with resource cleanup

;; Resource with return value from inner expression
(let [result (with-resource [temp-file File {:path "temp.txt"}]
               (println "Writing to temp file")
               "temporary data")]
  result)
;; ;; Expected: "temporary data" with temp file cleaned up

;; Resource with side effects
;; (with-resource [logger Logger {:path "app.log"}]
  (do
    (println "Starting operation")
    (let [result (+ 1 2)]
      (println "Operation completed")
      result)))
;; ;; Expected: 3 with logger cleanup and log entries

;; Resource pool management
;; (with-resource [db-pool ConnectionPool {:size 10}]
  (let [results []]
    (doseq [query [1 2 3]]
      (with-resource [conn Connection {:pool db-pool}]
        (conj! results (* query 2))))
    results))
;; ;; Expected: [2 4 6] with pool and connection cleanup

;; Resource with timeout (if supported)
;; (with-resource [lock Lock {:timeout 5000}]
  (if true
    (println "Critical section")
    :timeout))
;; ;; Expected: nil or :timeout with lock cleanup

;; Edge case: Resource creation fails
(try
  (with-resource [bad-resource BadResource (/ 1 0)]  ; This will cause a runtime error
    (println "Using bad resource"))
  (catch Exception e
    "creation-error"))
;; ;; Expected: "creation-error" (no cleanup needed if creation fails)

;; Edge case: Empty resource body
;; (with-resource [resource SimpleResource {:type "simple"}]
  nil)
;; ;; Expected: nil with resource cleanup

;; Edge case: Resource used after with-resource block (should be invalid)
(let [leaked-resource (with-resource [r Resource {:type "test"}]
                        r)]
  ; leaked-resource should be invalid here
  :leaked)
;; ;; Expected: :leaked (but leaked-resource should be invalid)
