;; Mutation & State minimal checks

;; 1) rebinding via let shadowing (pure)
;; Rewritten to avoid set!: create a new binding with the updated value and return it
(let [x 1]
  (let [x 2]
    x))
;; Expected: 2

;; 2) pure increment result
;; Avoid atom: compute the incremented value directly and return it
((fn []
   (let [c 0]
     (inc c))) )
;; Expected: 1

;; 3) sequential sum using pure reduce
(let [nums [0 1 2 3 4]]
  (reduce + 0 nums))
;; Expected: 10

;; 4) literal value test (deref sugar removed)
;; Return the literal value directly instead of dereferencing an atom
(let [a 42]
  a)
;; Expected: 42
