// --- Whitespace and Comments ---
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ (";" | ";;") ~ (!"\n" ~ ANY)* | "#|" ~ (!"|#" ~ ANY)* ~ "|#" }

// --- Terminal Characters ---
COLON = @{ ":" }
AMPERSAND = @{ "&" }

// --- Grammar Entry Point ---
// Note: task_definition is removed in favor of RTFS 2.0 objects.
program = { SOI ~ (module_definition | expression)* ~ EOI }

// --- Core Recursive Rule ---
// Order matters for precedence (e.g., special forms before general lists)
// Removed function_call, relying on list + parser heuristic
// Include anonymous and shorthand function forms before other possibilities so they capture '#(' sequences
// and method-call style tokens ('.method'). Keep explicit order for precedence.
expression = _{ shorthand_fn | anon_fn | method_call_expr | literal | keyword | symbol | task_context_access | resource_ref | special_form | list | vector | map }

// --- Basic Values ---

// Enhanced Literal Types for RTFS 2.0
timestamp = @{ ASCII_DIGIT{4} ~ "-" ~ ASCII_DIGIT{2} ~ "-" ~ ASCII_DIGIT{2} ~ "T" ~ ASCII_DIGIT{2} ~ ":" ~ ASCII_DIGIT{2} ~ ":" ~ ASCII_DIGIT{2} ~ ("_" ~ ASCII_DIGIT{3})? ~ "Z" }
uuid = @{ ASCII_HEX_DIGIT{8} ~ "-" ~ ASCII_HEX_DIGIT{4} ~ "-" ~ ASCII_HEX_DIGIT{4} ~ "-" ~ ASCII_HEX_DIGIT{4} ~ "-" ~ ASCII_HEX_DIGIT{12} }
resource_handle = @{ "resource://" ~ (!WHITESPACE ~ ANY)+ }

literal = { timestamp | uuid | resource_handle | special_float | float | integer | string | boolean | nil | keyword } // Added keyword and new RTFS 2.0 literals

integer = @{ ("-" | "+")? ~ ASCII_DIGIT+ }
float   = @{ ("-" | "+")? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? }
special_float = @{ "##Inf" | "##-Inf" | "##NaN" }

// String parsing rules:
// escape_sequence must be defined before string_char, and string_char before string.
// Accept any escaped character (\X). Unknown escapes are preserved and handled later by the unescape routine.
escape_sequence = { "\\" ~ ANY } // E.g. \", \n, \t, or any other escaped char preserved
string_char     = { escape_sequence | (!("\"" | "\\") ~ ANY) }
string          =  { "\"" ~ string_char* ~ "\"" }
boolean = @{ "true" | "false" }
nil     = @{ "nil" ~ !identifier_chars }

// --- Identifiers & Symbols ---
// Based on grammar_spec.md, allowing common Lisp chars. '.' is for ns, '-' is common.
// Allow dot-prefixed identifiers and shorthand placeholders like % and @ for context tokens
dot_prefixed_identifier = @{ "." ~ (ASCII_ALPHA | "_" | "$" | "+" | "-" | "*" | "/" | "=" | "<" | ">" | "!" | "?" ) ~ (ASCII_ALPHANUMERIC | "_" | "$" | "+" | "-" | "*" | "/" | "=" | "<" | ">" | "!" | "?" | ".")* }

identifier_start_char = _{ ASCII_ALPHA | "_" | "$" | "+" | "-" | "*" | "/" | "=" | "<" | ">" | "!" | "?" | "%" | "@" }
identifier_chars      = _{ identifier_start_char | ASCII_DIGIT | "." | "-" | "@" }
identifier            = @{ dot_prefixed_identifier | (identifier_start_char ~ identifier_chars*) }

// --- Versioned Namespacing Extension ---
version = @{ "v" ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)* }
versioned_namespace = @{ identifier ~ ("." ~ identifier)* ~ ":" ~ version ~ "/" ~ identifier }

// Namespaced identifier like my.module/my-function or just my-function
// Allowing multiple '.' for ns parts before the '/'
namespaced_identifier = @{ identifier ~ ("." ~ identifier)* ~ "/" ~ identifier }

// A symbol is typically represented by an identifier or namespaced identifier in code
symbol = { versioned_namespace | namespaced_identifier | identifier }

// --- Keywords ---
// Simple keyword like :foo or qualified like :my.ns/foo or versioned like :com.acme:v1.0/foo
keyword = @{ ":" ~ (versioned_namespace | namespaced_identifier | identifier) }

// Add this after the existing symbol rule and before collections
// Task context access using @ prefix
task_context_access = { "@" ~ (identifier | keyword) }


vector_match_pattern    = { "[" ~ match_pattern* ~ ("&" ~ symbol)? ~ "]" }
map_match_pattern_entry = { map_key ~ match_pattern }
map_match_pattern       = { "{" ~ map_match_pattern_entry* ~ ("&" ~ symbol)? ~ "}" }

as_match_pattern = { "(" ~ ":as" ~ symbol ~ match_pattern ~ ")" } // Specific rule for :as

match_pattern = _{
    literal
  | keyword // Keyword before symbol if keywords can look like symbols
  | wildcard // Wildcard before symbol
  | symbol 
  | type_expr // Matching on type might be complex, placeholder
  | as_match_pattern // Use the specific :as pattern rule
  | vector_match_pattern
  | map_match_pattern 
}

// --- Collections ---
// These now explicitly contain 'expression'
list      = { "(" ~ expression* ~ ")" }
vector    = { "[" ~ expression* ~ "]" }
map       = { "{" ~ map_entry* ~ "}" }
map_entry = { map_key ~ expression }
// Allowing keywords, strings, or integers as map keys for now (as per grammar_spec)
map_key = { keyword | string | integer }

// Shorthand anonymous function using Clojure-style reader macro: #( ... ) with % %1 %2 ...
// Parses as its own rule; later transformed into a normal fn expression in parser.
shorthand_fn = { "#" ~ "(" ~ expression* ~ ")" }

// Anonymous function shorthand: #(...)
anon_fn = { "#" ~ "(" ~ expression* ~ ")" }

// Method call interop: (.method target arg*) desugared in parser to (method target arg*)
method_call_expr = { "(" ~ "." ~ identifier ~ expression+ ~ ")" }

// --- Type Expressions (Based on grammar_spec.md) ---
primitive_type = { symbol | keyword }
// Accept both bare symbols (int) and keyword forms (:int) for primitive types for backward compatibility

// Complex Type Rules (assuming list-based syntax like [:vector T], [:map ...], etc.)
optional_marker = { "?" }
vector_type    = { "[" ~ ":vector" ~ WHITESPACE* ~ type_expr ~ WHITESPACE* ~ "]" }
// Map type entry supports two styles used in tests:
//  - Bracketed single-entry: [ :key Type ]
//  - Braced compact form: { :key Type :key2 Type2 }
map_type_entry = { "[" ~ keyword ~ WHITESPACE* ~ type_expr ~ (WHITESPACE* ~ optional_marker)? ~ WHITESPACE* ~ "]" }
map_type_entry_braced = { "{" ~ (WHITESPACE* ~ keyword ~ WHITESPACE* ~ type_expr ~ (WHITESPACE* ~ optional_marker)? )+ ~ WHITESPACE* ~ "}" }
// [Key Type Optional?]
map_type_wildcard = { "[" ~ ":*" ~ WHITESPACE* ~ type_expr ~ WHITESPACE* ~ "]" }
// [:* WildcardType]
map_type            = { "[" ~ ":map" ~ (WHITESPACE* ~ (map_type_wildcard | map_type_entry | map_type_entry_braced))* ~ WHITESPACE* ~ "]" }
tuple_type          = { "[" ~ ":tuple" ~ (WHITESPACE* ~ type_expr)+ ~ WHITESPACE* ~ "]" }
param_type          = { type_expr }
variadic_param_type = { "&" ~ WHITESPACE* ~ type_expr }
function_type       = { "[" ~ (":fn" | ":=>") ~ WHITESPACE* ~ "[" ~ (WHITESPACE* ~ param_type)* ~ (WHITESPACE* ~ variadic_param_type)? ~ WHITESPACE* ~ "]" ~ WHITESPACE* ~ type_expr ~ WHITESPACE* ~ "]" }
// [:fn [Params...] Variadic? Return]
resource_type     = { "[" ~ ":resource" ~ WHITESPACE* ~ symbol ~ WHITESPACE* ~ "]" }
enum_type         = { "[" ~ ":enum" ~ (WHITESPACE* ~ literal)+ ~ WHITESPACE* ~ "]" }
union_type        = { "[" ~ ":union" ~ (WHITESPACE* ~ type_expr)+ ~ WHITESPACE* ~ "]" }
// Using :union for mathematical consistency and brevity
// Allow a primitive_type (which can be a bare symbol) or general type_expr as the base of an intersection
// Intersection / refinement: first element is base type; following elements may be predicates
// Intersection or refined type. Base followed by one or more predicates or additional types.
// We first try to parse predicates; if non-predicate type_exprs appear they are treated as intersection members.
intersection_type = { "[" ~ ":and" ~ WHITESPACE* ~ (primitive_type | type_expr) ~ (WHITESPACE* ~ (predicate_expr | type_expr))+ ~ WHITESPACE* ~ "]" }
literal_type      = { "[" ~ ":val" ~ WHITESPACE* ~ literal ~ WHITESPACE* ~ "]" }

// Also add array shapes support (mentioned in specs but missing from grammar)
dimension = { integer | "?" }
shape = { "[" ~ dimension* ~ "]" }
array_type = { "[" ~ ":array" ~ WHITESPACE* ~ type_expr ~ WHITESPACE* ~ shape? ~ WHITESPACE* ~ "]" }

// Main type expression rule
type_expr = _{ 
    optional_type |
    primitive_type | 
    vector_type | 
    map_type | 
    tuple_type | 
    function_type | 
    resource_type | 
    enum_type |
    union_type | 
    intersection_type | 
    literal_type |
    array_type
}

// Optional type: T? (sugar for [:union T :nil])
// Allow either primitive symbol, keyword primitive, or general symbol before '?'
optional_type = { (primitive_type | symbol) ~ optional_marker }

// Add schema predicate support for type refinements
// Support common predicates like [:> 0], [:min-length 3], [:matches-regex "pattern"]
predicate_expr = { 
    comparison_predicate | 
    length_predicate | 
    regex_predicate | 
    range_predicate |
    collection_predicate |
    map_predicate |
    custom_predicate 
}

// Predicate operator helper rules (captured for easier parsing)
comparison_operator = { ":>" | ":>=" | ":<" | ":<=" | ":=" | ":!=" }
length_operator     = { ":min-length" | ":max-length" | ":length" }
regex_operator      = { ":matches-regex" }
range_operator      = { ":in-range" }
collection_operator = { ":min-count" | ":max-count" | ":count" | ":non-empty" }
map_operator        = { ":has-key" | ":required-keys" }

// Comparison predicates: [:> value], [:>= value], etc.
comparison_predicate = { "[" ~ comparison_operator ~ WHITESPACE* ~ literal ~ "]" }

// Length predicates: [:min-length n], [:max-length n], [:length n]
length_predicate = { "[" ~ length_operator ~ WHITESPACE* ~ integer ~ "]" }

// Regex predicate: [:matches-regex "pattern"]
// Use literal so parser's build_literal helper can process it (must be a string literal at runtime)
regex_predicate = { "[" ~ regex_operator ~ WHITESPACE* ~ literal ~ "]" }

// Range predicate: [:in-range min max]
range_predicate = { "[" ~ range_operator ~ WHITESPACE* ~ literal ~ WHITESPACE* ~ literal ~ "]" }

// Collection predicates: [:min-count n], [:max-count n], [:non-empty], etc.
collection_predicate = { "[" ~ collection_operator ~ (WHITESPACE* ~ integer)? ~ "]" }

// Map predicates: [:has-key :key], [:required-keys [:k1 :k2]]
keys_list = { "[" ~ (WHITESPACE* ~ keyword)* ~ WHITESPACE* ~ "]" }
map_predicate = { "[" ~ map_operator ~ WHITESPACE* ~ (keyword | keys_list) ~ "]" }

// Custom/fallback predicate: any other predicate format
custom_predicate = { "[" ~ predicate_name ~ literal* ~ "]" }
predicate_name = { keyword | symbol }

// --- Patterns (Destructuring) ---
wildcard = @{ "_" }
// Added explicit wildcard rule

// Define these before binding_pattern uses them
keys_entry = { ":keys" ~ "[" ~ symbol* ~ "]" }
symbol_key_binding = { symbol ~ map_key }
map_destructuring_entry = { keys_entry | map_key ~ binding_pattern | symbol_key_binding }

map_rest_binding = { "&" ~ symbol }
map_as_binding = { ":as" ~ symbol }
map_destructuring_pattern = {
    "{" ~
    map_destructuring_entry* ~
    map_rest_binding? ~
    map_as_binding? ~
    "}"
}

vector_rest_binding = { "&" ~ symbol }
vector_as_binding = { ":as" ~ symbol }
vector_destructuring_pattern = {
    "[" ~
    binding_pattern* ~
    vector_rest_binding? ~
    vector_as_binding? ~
    "]"
}


binding_pattern = _{ wildcard | symbol | map_destructuring_pattern | vector_destructuring_pattern }
// Added wildcard

// --- Special Forms ---
log_step_expr = { "(" ~ log_step_keyword ~ keyword? ~ expression* ~ ")" }

special_form = _{ let_expr | if_expr | do_expr | fn_expr | def_expr | defn_expr | defstruct_expr | parallel_expr | with_resource_expr | try_catch_expr | match_expr | log_step_expr | discover_agents_expr }
// Removed module_definition, import_definition, and task_definition as they are top-level, not expressions.

do_keyword = @{ "do" ~ (WHITESPACE | &(")" | "(" | "\"" | "[" | "]" | "{" | "}" | ":" | ";")) }
// Added for clarity and robustness - must be followed by whitespace or delimiter to avoid matching "do-something"

let_keyword = @{ "let" }
let_binding = { binding_pattern ~ type_annotation? ~ expression }
let_expr = { "(" ~ let_keyword ~ WHITESPACE* ~ "[" ~ (WHITESPACE* ~ let_binding)* ~ WHITESPACE* ~ "]" ~ (WHITESPACE* ~ expression)+ ~ ")" }

if_expr = { "(" ~ "if" ~ expression ~ expression ~ expression? ~ ")" }
// Made else optional for now

// do_expr = @{ "(" ~ "do" ~ expression* ~ ")" } // Original
do_expr = { "(" ~ do_keyword ~ expression* ~ ")" }
// Modified to use do_keyword
// Ensure atomic and matches "do" keyword

fn_param_list = { "[" ~ param_def* ~ (AMPERSAND ~ symbol ~ (COLON ~ type_expr)?)? ~ "]" } // New rule for parameter lists

fn_expr   = { "(" ~ fn_keyword ~ WHITESPACE* ~ metadata* ~ WHITESPACE* ~ fn_param_list ~ (COLON ~ type_expr)? ~ expression+ ~ ")" } // Added WHITESPACE* between metadata and param list
param_def = { binding_pattern ~ (COLON ~ type_expr)? }

def_expr  = { "(" ~ def_keyword ~ symbol ~ (COLON ~ type_expr)? ~ expression ~ ")" } // Use def_keyword
defn_expr = { "(" ~ defn_keyword ~ symbol ~ WHITESPACE* ~ metadata* ~ WHITESPACE* ~ fn_param_list ~ (COLON ~ type_expr)? ~ expression+ ~ ")" } // Added WHITESPACE* between metadata and param list

// defstruct rule for ergonomic struct definitions
defstruct_expr = { "(" ~ defstruct_keyword ~ symbol ~ defstruct_field* ~ ")" }
defstruct_field = { keyword ~ type_expr }

parallel_expr    = { "(" ~ parallel_keyword ~ parallel_binding+ ~ ")" } // Use parallel_keyword
parallel_binding = { "[" ~ symbol ~ type_annotation? ~ expression ~ "]" }
type_annotation = { COLON ~ type_expr }

with_resource_expr = { "(" ~ with_resource_keyword ~ "[" ~ symbol ~ type_expr ~ expression ~ "]" ~ expression+ ~ ")" } // Use with_resource_keyword

// Define a rule for expressions that can appear in a try block's body.
// It must not be a catch_clause or finally_clause itself.
// This prevents expression+ from consuming catch/finally clauses.
try_body_expression = _{ !(catch_clause | finally_clause) ~ expression }

try_catch_expr = { "(" ~ try_keyword ~ try_body_expression* ~ catch_clause* ~ finally_clause? ~ ")" } // Use try_keyword and try_body_expression; allow empty try body
// Changed + to * for catch
catch_clause   =  { "(" ~ catch_keyword ~ symbol ~ symbol? ~ expression+ ~ ")" } // Use catch_keyword
finally_clause =  { "(" ~ finally_keyword ~ expression+ ~ ")" } // Use finally_keyword
catch_pattern  = _{ type_expr | keyword | symbol }
// symbol implies catch-all

// Flat syntax: (match expr pattern1 body1 pattern2 body2 ...)
match_expr    =  { "(" ~ match_keyword ~ expression ~ (match_clause_content)+ ~ ")" } 
match_clause_content = { match_pattern ~ (WHEN ~ expression)? ~ expression } // pattern, optional guard, then body expressions
WHEN = @{ "when" ~ (WHITESPACE | &(")" | "(" | "\"" | "[" | "]" | "{" | "}" | ":" | ";")) } // Keyword for guard - now atomic

// Agent discovery expression: (discover-agents criteria-map options-map?)
discover_agents_expr = { "(" ~ discover_agents_keyword ~ expression ~ expression? ~ ")" }

// (plan ...) has been removed from RTFS core grammar. Plans are CCOS objects represented
// either as function calls (ccos/plan ...) or maps at the CCOS layer and extracted there.

// --- Top-Level Definitions ---
module_keyword = @{ "module" }
import_keyword = @{ "import" }

// Keywords for special forms
fn_keyword = @{ "fn" | "Î»" }
def_keyword = @{ "def" }
defn_keyword = @{ "defn" }
defstruct_keyword = @{ "defstruct" }
// let_keyword is already defined
// if_keyword is not needed as "if" is not ambiguous with symbols in the same way
parallel_keyword = @{ "parallel" }
with_resource_keyword = @{ "with-resource" }
try_keyword = @{ "try" }
catch_keyword = @{ "catch" }
finally_keyword = @{ "finally" }
match_keyword = @{ "match" ~ (WHITESPACE | &(")" | "(" | "\"" | "[" | "]" | "{" | "}" | ":" | ";")) } // Made atomic
log_step_keyword = @{ "log-step" ~ (WHITESPACE | &(")" | "(" | "\"" | "[" | "]" | "{" | "}" | ":" | ";")) } // Made atomic
discover_agents_keyword = @{ "discover-agents" ~ (WHITESPACE | &(")" | "(" | "\"" | "[" | "]" | "{" | "}" | ":" | ";")) } // Agent discovery keyword


// module_definition =  { "(" ~ "module" ~ namespaced_identifier ~ export_option? ~ definition* ~ ")" }
module_definition =  { "(" ~ module_keyword ~ (symbol | namespaced_identifier) ~ export_option? ~ definition* ~ ")" } // Changed namespaced_identifier to symbol and used module_keyword

// Corrected export_option structure
exports_keyword   = @{ ":exports" } 
export_symbols_vec = { "[" ~ (WHITESPACE* ~ symbol)+ ~ WHITESPACE* ~ "]" }
export_option     =  { "(" ~ exports_keyword ~ WHITESPACE* ~ export_symbols_vec ~ WHITESPACE* ~ ")" }

definition        = _{ def_expr | defn_expr | import_definition }
import_definition =  { "(" ~ import_keyword ~ (symbol | namespaced_identifier) ~ (import_option* ) ~ ")" } // Allow multiple flat import options
import_option      = { ":as" ~ symbol | ":only" ~ "[" ~ symbol+ ~ "]" } // Normal rule, singular

// --- Resource Reference Syntax ---
resource_ref_keyword = @{ "resource:ref" }
resource_ref = { "(" ~ resource_ref_keyword ~ string ~ ")" }

// --- Delegation Metadata ---
metadata = { delegation_meta }

delegation_meta = { "^" ~ ":delegation" ~ WHITESPACE* ~ delegation_target }

delegation_target = { local_model_delegation | remote_delegation | local_delegation }

local_delegation = { ":local" ~ !("-") }
local_model_delegation = { ":local-model" ~ WHITESPACE* ~ string? }
remote_delegation = { ":remote" ~ WHITESPACE* ~ string? }

