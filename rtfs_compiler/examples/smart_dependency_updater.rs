//! Example: Smart Dependency Updater (Intent-Driven with DelegatingArbiter)
//!
//! This revamped example shows how to drive the CCOS Arbiter end-to-end:
//! 1.  Natural-language prompt ‚Üí Intent (using an LLM via DelegatingArbiter)
//! 2.  Intent ‚Üí RTFS Plan (generated by the same LLM)
//! 3.  Plan executed with the RTFS runtime (delegating specific functions to the LLM as needed)
//!
//! It relies on a local model (llama.cpp) so you can run it offline on a GPU.

use std::sync::Arc;

use rtfs_compiler::ccos::delegation::ModelRegistry;
use rtfs_compiler::ccos::local_models::LocalLlamaModel;
use rtfs_compiler::ccos::DelegatingArbiter;
use rtfs_compiler::ccos::arbiter_engine::ArbiterEngine;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ü§ñ CCOS Smart Dependency Updater Demo (Delegating Arbiter)");
    println!("==========================================================");
    println!();

    // 1.  Set up local model + registry //////////////////////////////////////////////////////
    let model_path = std::env::var("RTFS_LOCAL_MODEL_PATH")
        .unwrap_or_else(|_| "models/phi-2.Q4_K_M.gguf".to_string());

    if !std::path::Path::new(&model_path).exists() {
        println!("‚ùå Model not found. Please run ./scripts/download_model.sh or set RTFS_LOCAL_MODEL_PATH.");
        return Ok(());
    }
    println!("‚úÖ Using local model: {}", model_path);

    let registry = Arc::new(ModelRegistry::new());
    let local_llama = LocalLlamaModel::new("local-analyzer", &model_path, None);
    registry.register(local_llama);

    // 2.  Instantiate DelegatingArbiter ///////////////////////////////////////////////////////
    let arbiter = DelegatingArbiter::new(Arc::clone(&registry), "local-analyzer")?;

    // 3.  Provide a realistic prompt //////////////////////////////////////////////////////////
    let user_prompt = "Check my project for outdated Cargo dependencies and suggest update steps.";
    println!("üó£Ô∏è  User Prompt: \"{}\"", user_prompt);

    // 4.  Walk through the Arbiter phases explicitly so we can log each step.
    println!("\n--- Phase 1: NL ‚Üí Intent -------------------------------------------------");
    let intent = match arbiter.natural_language_to_intent(user_prompt, None).await {
        Ok(intent) => {
            println!("Generated Intent:\n{:#?}", intent);
            intent
        }
        Err(e) => {
            eprintln!("‚ùå Failed to create intent: {}", e);
            return Ok(());
        }
    };

    println!("\n--- Phase 2: Intent ‚Üí Plan ------------------------------------------------");
    let plan = match arbiter.intent_to_plan(&intent).await {
        Ok(plan) => {
            match &plan.body {
                rtfs_compiler::ccos::types::PlanBody::Text(txt) => {
                    println!("Generated Plan (RTFS code):\n{}", txt);
                }
                _ => println!("Generated non-text plan: {:#?}", plan.body),
            }
            plan
        }
        Err(e) => {
            eprintln!("‚ùå Failed to create plan: {}", e);
            return Ok(());
        }
    };

    println!("\n--- Phase 3: Execute Plan -------------------------------------------------");
    match arbiter.execute_plan(&plan).await {
        Ok(result) => {
            println!("Execution Result:\n{:#?}", result);
        }
        Err(e) => {
            eprintln!("‚ùå Execution error: {}", e);
        }
    }

    Ok(())
}
