# ACL Language Prospections

This document captures forward-looking ideas, design considerations, and discussions about the potential evolution and deeper philosophy of the AI-Centric Language (ACL), centered around the `task` artifact.

## 1. The `task` Form: Unifying Intent, Plan, and History

**Concept:** ACL revolves around the `task` form, a comprehensive data structure generated by an AI from a human instruction. It serves as a rich intermediate representation capturing:
    a.  The original **context** and natural language instruction.
    b.  The derived semantic **intent** (`:intent`).
    c.  The procedural **execution plan** (`:plan`, as executable ACL code).
    d.  An immutable **execution log** (`:execution-log`) tracking planning evolution and execution status.

**Alignment with ACL Design:**

*   **S-expressions & Homoiconicity:** Ideal for embedding structured metadata (`:intent`, log entries) alongside executable code (`:plan`) within the unified `task` structure.
*   **Data Structures (`Value`):** Suitable for representing intent, code, and log metadata.
*   **Functional Core & Predictability:** Makes the `:plan` easier for AI to generate reliably.
*   **Static Typing (Planned):** Can enforce structure on `:intent`, `:plan`, and `:execution-log` entries.

**Structural Implementation:**

*   **`task` Form:** The central structure, likely represented as a Map or dedicated type, containing keys like `:id`, `:source`, `:natural-language`, `:intent`, `:plan`, and `:execution-log`.
*   **`:intent` Block:** Captures the structured semantic goal. Its structure is domain-specific.
*   **`:execution-log`:** An immutable list tracking planning and execution stages. Each stage contains metadata (agent, timestamp, status, derived-from) and potentially references or includes a `:plan` (an `Expr`).
*   **Standard Library:** Includes primitives for actions relevant to developer instructions (file I/O, AST manipulation, terminal commands, workflow commands like `:send-planner`), managed via controlled side effects (see Section 3).

**Example Sketch (GitHub Issue Fetching - Initial Task):**

```acl
(task ;; Top-level form representing the instruction and its execution
  :id "gh-fetch-bugs-001"
  :source "human-instruction"
  :natural-language "Fetch the list of open issues labeled 'bug' from the acl-compiler repo and save their titles to bug_titles.txt"

  :intent { ;; Structured representation of the goal
    :action :fetch-filter-save
    :data-source { :type :github-issues :repo "acl-compiler" :state :open }
    :filter-criteria { :label "bug" }
    :data-to-extract :title
    :destination { :type :file :path "bug_titles.txt" }
  }

  :execution-log [ ;; Initial log with planning request
    { :stage 1
      :agent "Formulator-AI"
      :timestamp "2025-04-21T10:00:00Z"
      :status :planning-requested
      :plan (:send-planner {}) ;; Request planning by another agent/stage
    }
  ]
)
```

## 2. Integrating External Tools into the `:plan`

**Concept:** ACL execution plans (`:plan` field within a `task`) seamlessly incorporate calls to external tools (local CLIs, APIs, IDE functions) as primitive operations.

**Compatibility:** This fits perfectly with the ACL-as-plan idea. The "how" (execution steps) can include these tool calls.

**Implementation:**

*   **Representing Tool Calls:** Define specific ACL functions/primitives within the standard library (e.g., `(tool:read-file path)`, `(tool:run-terminal-command cmd)`, `(tool:semantic-search query)`).
*   **Standard Library:** Include these primitives with defined types.
*   **Runtime Role:** The interpreter/compiler executes these calls when evaluating the `:plan`, interacting with the OS/environment/host IDE.
*   **Data Flow:** Marshal tool results back into ACL `Value` types.
*   **Controlled Side Effects:** Tool calls are inherently side effects and must be managed within the planned monadic context (e.g., `IO`).

**Benefits:**

*   **Unified Plan:** Single ACL structure for internal logic and external actions.
*   **Leverage Capabilities:** Use existing powerful tools.
*   **Transparency:** Plan explicitly shows tool usage.

## 3. Managing Mutable/Remote Resources via Handles

**Challenge:** Balancing the need for efficient mutation of large resources (like tensors, GPU buffers, open files, network connections) with ACL's goal of predictability, while handling resource lifecycles and potential remoteness.

**Proposed Approach: Opaque Handles + Controlled Operations (within IO/Resource Monad)**

1.  **Opaque Resource Handles:** Use an immutable ACL `Value::ResourceHandle { id: ResourceId, type_tag: String }` that refers to the actual resource managed *outside* the core ACL value system by the runtime.
2.  **Runtime Resource Management:** The Rust runtime manages the lifecycle (allocation, deallocation) and location (CPU, GPU, remote) of the actual resource data, mapping `ResourceId`s to it.
3.  **Controlled Primitive Operations:** Define specific, built-in ACL functions that operate on handles. Operations causing mutation or side effects (allocation, mutation, deallocation, data transfer) return results within the `IO` (or specialized `Resource`) monad.
    *   Examples: `(alloc-tensor shape dtype) -> (IO TensorHandle)`, `(free-resource! handle) -> (IO Void)`, `(tensor-add! result-h t1-h t2-h) -> (IO Void)`, `(tensor-read handle indices) -> (IO Value)`, `(tensor-send handle target-device) -> (IO TensorHandle)`, `(file-open path mode) -> (IO FileHandle)`, `(file-write! handle data) -> (IO Void)`, `(file-close! handle) -> (IO Void)`.
4.  **Monadic Sequencing:** Use `(do ...)` to ensure effectful operations occur in the correct order, confining mutation and side effects.

**Benefits:**

*   Preserves predictability in the pure parts of ACL.
*   Abstracts resource location and management details behind handles.
*   Provides explicit control over resource lifecycles and side effects.
*   Structured enough for AI generation.

**Example Snippet (Conceptual Tensor Ops):**

```acl
(do
  [handle1 : TensorHandle (alloc-tensor [100 100] :float32)]
  [handle2 : TensorHandle (alloc-tensor [100 100] :float32)]
  [handle_sum : TensorHandle (alloc-tensor [100 100] :float32)]

  (_ : Void (tensor-fill! handle1 1.0))
  (_ : Void (tensor-fill! handle2 2.0))

  ;; Perform mutation via primitive
  (_ : Void (tensor-add! handle_sum handle1 handle2))

  ;; Read a value (potentially copies)
  [val : Float (tensor-read handle_sum [50 50])]
  (_ : Void (print (string-append "Value: " (float->string val))))

  ;; Clean up
  (_ : Void (free-resource! handle1))
  (_ : Void (free-resource! handle2))
  (_ : Void (free-resource! handle_sum))

  (pure_io :success)
)
```

## 4. Execution Tracking and Parallelism via `:execution-log`

**Concept:** Utilize the immutable `:execution-log` within the `task` to support detailed execution status tracking and enable complex, traceable workflows, including parallel execution defined in the `:plan`.

**Approach: Execution Log + Structured Plans + Status Updates**

1.  **Structured Plans (`:plan` field):** Introduce ACL constructs within the plan to manage control flow:
    *   `(do step1 step2 ...)`: Sequential execution.
    *   `(parallel [step-id-1 plan-expr-1] [step-id-2 plan-expr-2] ...)`: Defines steps that can run concurrently, each identified by a unique `step-id` (Symbol or String) within the scope of the `parallel` form.
    *   `(join step-id-1 step-id-2 ...)`: Synchronization point; waits for specified parallel steps (identified by their `step-id` from the enclosing `parallel`) to complete. Returns a map of step-ids to their results or signals an error if any joined step failed.
    *   `(log-step :id <id> <expr>)`: Optionally wrap expressions to ensure their start/completion is explicitly logged in the `:execution-log` with the given ID.
    *   `(result <step-id>)`: Hypothetical construct to access the result of a previously completed step (identified by its ID) from the `:execution-log` or the result map returned by `join`.

2.  **Execution Log (`:execution-log` field):** An append-only list within the `task` tracking planning *and* execution state transitions.
    *   **Planning Stages:** Record the evolution of the `:plan` itself (e.g., initial request, plan generated, plan revised).
    *   **Execution Stages:** When the executor processes a step from the `:plan`:
        *   Append a log entry marking the step as `:status :running` (referencing the step ID if available via `log-step` or inferred).
        *   Upon completion, append another entry referencing the 'running' stage, marking it `:status :completed` with a `:result`, or `:status :failed` with an `:error`.

3.  **Executor Role:**
    *   Interprets the `:plan` from the latest relevant stage in the `:execution-log`.
    *   Appends new log entries to the `:execution-log` reflecting the execution status.
    *   Manages concurrency for `(parallel ...)` blocks.
    *   Uses the `:execution-log` to resolve `(join ...)` dependencies and potentially `(result ...)` calls.

**Example Structure (within `:execution-log`):**

```acl
  :execution-log [
    { :stage 1 :agent "Formulator" :timestamp "..." :status :planning-requested :plan (:send-planner {}) }

    { :stage 2 :agent "Planner" :timestamp "..." :derived-from 1 :status :plan-generated
      :plan (do
              (parallel
                ["fetch-A" (log-step :id "fetch-A" (tool:fetch-data "source-A"))]
                ["fetch-B" (log-step :id "fetch-B" (tool:fetch-data "source-B"))])
              (let ([join-results (join "fetch-A" "fetch-B")])
                   (log-step :id "process" (process-results (map-ref join-results "fetch-A") 
                                                             (map-ref join-results "fetch-B")))))
    }

    ;; --- Execution Phase --- starts interpreting plan from stage 2
    { :stage 3 :agent "Executor" :timestamp "..." :derived-from 2 :executing-step "fetch-A" :status :running }
    { :stage 4 :agent "Executor" :timestamp "..." :derived-from 2 :executing-step "fetch-B" :status :running }
    { :stage 5 :agent "Executor" :timestamp "..." :derived-from 3 :executed-step "fetch-A" :status :completed :result "<data-A>" }
    { :stage 6 :agent "Executor" :timestamp "..." :derived-from 4 :executed-step "fetch-B" :status :failed :error {:type :network-error ...} }
    ;; ... execution potentially stops or handles error based on join dependency ...
    { :stage 7 :agent "Executor" :timestamp "..." :derived-from 2 :executing-step "join" :status :failed :error {:type :dependency-failed :step "fetch-B" ...} }
  ]
```

**Advantages:**

*   **Full Traceability:** Complete planning and execution history.
*   **Handles Parallelism:** Explicit representation and tracking.
*   **Status Tracking:** Fine-grained status recorded immutably.
*   **Immutability:** Log is append-only.
*   **Resilience:** Potential for resuming tasks by analyzing the log.

**Challenges:**

*   **Log Verbosity:** Requires careful management or summarization.
*   **Executor Complexity:** Needs to handle concurrency, log interpretation, and state management.
*   **Result Propagation:** Accessing results (`(result ...)` or via `join`) needs a robust mechanism tied to the log and execution state.

This approach provides a comprehensive framework for representing and tracking complex, potentially parallel AI tasks within ACL.

## 5. Interoperability: MCP Compliance

**Concept:** Ensure ACL can operate within an ecosystem using the Model Context Protocol (MCP, defined in `schema.ts`). ACL is not a protocol itself, but its runtime environment can interact with or implement MCP.

**Compliance & Integration:**

1.  **ACL Runtime as MCP Server:** An ACL interpreter/runtime can be exposed as an MCP server. It would handle MCP requests (e.g., `initialize`, `tools/list`, `tools/call`, `resources/list`, `resources/read`).
    *   Incoming `tools/call` requests could trigger the execution of specific ACL functions or plans.
    *   The server would declare its capabilities, potentially listing ACL-specific operations as MCP tools.
    *   ACL's internal state and resource management could be exposed via MCP resource endpoints.
2.  **ACL Plan using MCP Primitives:** The ACL language can include built-in primitives that allow an ACL `:plan` to interact with MCP services.
    *   Examples: `(mcp:call-tool "tool-name" {...})`, `(mcp:read-resource "uri")`, `(mcp:list-resources)`.
    *   The ACL interpreter executes these primitives by making the corresponding JSON-RPC calls to an MCP server.
    *   Results (like `CallToolResult`, resource contents) are mapped back into ACL `Value` types.
3.  **Complementarity:** ACL complements MCP by providing:
    *   A structured language (`:plan`) for defining complex logic that *uses* MCP tools/resources, going beyond simple sequences.
    *   A dedicated representation for semantic intent (`:intent`).
    *   A rich, immutable execution history (`:execution-log`).

**Challenges:** Mapping between ACL's data model and JSON/JSON Schema; handling asynchronous MCP notifications within the ACL execution model.

## 6. Interoperability: A2A Compliance

**Concept:** Ensure ACL can interoperate with the Agent2Agent (A2A) protocol (summarized in `resources/llms.txt`), which defines communication between disparate AI agents.

**Compliance & Integration:**

1.  **ACL Runtime as A2A Agent:** Similar to MCP, an ACL runtime can implement the A2A server protocol.
    *   It would handle A2A JSON-RPC methods like `tasks/send`, `tasks/get`, `tasks/cancel`.
    *   Receiving `tasks/send` could instantiate an ACL `task`.
    *   The execution of the ACL `:plan` would drive the A2A `Task` lifecycle, emitting `TaskStatusUpdateEvent` and `TaskArtifactUpdateEvent` (via SSE or push notifications).
    *   ACL functions could generate A2A `Artifact`s (text, files, data).
    *   The agent's capabilities would be described in an `AgentCard`.
2.  **ACL Plan using A2A Primitives:** ACL can include primitives for acting as an A2A *client*.
    *   Examples: `(a2a:send <agent-url> <message-map>)`, `(a2a:get-task <agent-url> <task-id>)`.
    *   The interpreter executes these by making A2A calls to other agents.
    *   A2A responses (`Task`, `Artifact`) are mapped back to ACL `Value` types.
3.  **Complementarity:** ACL provides a robust internal representation (`task` artifact with `:intent`, `:plan`, `:execution-log`) for the work being managed and communicated via the A2A protocol. A2A defines the wire format and interaction patterns, while ACL defines the structure of the work itself.

**Conclusion:** ACL fits naturally into MCP and A2A ecosystems. It can serve as the engine within an agent participating in these protocols, using its structured `task` representation to manage intent, planning, and execution while leveraging the protocols for communication and tool/resource access.
