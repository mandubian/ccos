# RTFS Language Prospections

This document captures forward-looking ideas, advanced features, and speculative discussions about the evolution of the Reasoning Task Flow Specification (RTFS). For core concepts, see `language_motivation.md`.

## Advanced Execution Log and Parallelism

RTFS aims to support not just sequential but also complex parallel and concurrent workflows. The `:execution-log` is designed to enable:
- Fine-grained tracking of planning and execution events.
- Native constructs for parallel execution (`(parallel ...)`), synchronization (`(join ...)`), and explicit step logging (`(log-step ...)`).
- Advanced result propagation and error handling, such as referencing results of previous steps or handling failures in joined steps.

**Example:**
```rtfs
:execution-log [
  { :stage 1 :agent "Formulator" :timestamp "..." :status :planning-requested :plan (:send-planner {}) }
  { :stage 2 :agent "Planner" :timestamp "..." :derived-from 1 :status :plan-generated
    :plan (do
            (parallel
              ["fetch-A" (log-step :id "fetch-A" (tool:fetch-data "source-A"))]
              ["fetch-B" (log-step :id "fetch-B" (tool:fetch-data "source-B"))])
            (let ([join-results (join "fetch-A" "fetch-B")])
                 (log-step :id "process" (process-results (map-ref join-results "fetch-A")
                                                           (map-ref join-results "fetch-B"))))) }
  ;; ... further execution and error handling ...
]
```

## Resource Handles and Controlled Side Effects

RTFS plans to manage mutable or remote resources (e.g., tensors, files, network connections) using opaque handles and controlled operations, inspired by monadic patterns:
- Resources are referenced by immutable handles managed outside the core value system.
- All mutations and side effects are explicit and sequenced using constructs like `(do ...)`.
- This approach preserves predictability and enables robust AI code generation.

**Example:**
```rtfs
(do
  [handle1 : TensorHandle (alloc-tensor [100 100] :float32)]
  (_ : Void (tensor-fill! handle1 1.0))
  ;; ... more resource operations ...
  (_ : Void (free-resource! handle1))
  (pure_io :success)
)
```

## Interoperability: MCP and A2A Protocols

RTFS is designed to interoperate with broader AI ecosystems:
- **MCP (Model Context Protocol):** RTFS runtimes can act as MCP servers, exposing tools and resources, and can use MCP primitives in plans.
- **A2A (Agent2Agent):** RTFS can serve as the internal language for agents participating in A2A, supporting task exchange, status updates, and artifact generation.

**Challenges and Future Work:**
- Mapping between RTFS data and JSON/JSON Schema for protocol compliance.
- Handling asynchronous events and notifications in the RTFS execution model.

## Explicit Task Contracts (Input/Output/Tools)

A potential enhancement is to make the `task` artifact more self-describing and verifiable by adding explicit contracts, likely generated by the planner alongside the `:plan`:

- **`:required-tools` (list/set):** Explicitly lists the external tools, agents, or libraries the `:plan` depends on. Allows for upfront validation by the runtime environment to check if all dependencies are met before execution.
- **`:input-contract` (spec/schema):** Defines the expected structure and types of data the task requires as input to start its `:plan`. Enables input validation.
- **`:output-contract` (spec/schema):** Defines the guaranteed structure and types of the data the task will produce upon successful completion of its `:plan`. Enables output validation and safer composition.

**Benefits:**
- **Enhanced Validation:** Enables pre-execution checks for tool availability and runtime validation of input/output data against formal schemas (e.g., using `spec` or `malli`).
- **Improved Clarity:** Provides unambiguous specifications for AI planners (defining constraints) and orchestrators (understanding task capabilities).
- **Composability:** Facilitates safer composition of tasks by ensuring data compatibility between outputs and inputs.
- **Self-Documentation:** Embeds machine-readable documentation of dependencies and interfaces within the task itself.

**Considerations:**
- **Verbosity:** Adds more fields to the `task` map.
- **Contract Format:** Requires defining a standard way to represent these contracts (e.g., embedded `spec` or `malli` definitions).
- **Synchronization:** Contracts might need updates if the plan is modified (e.g., during replanning).

This approach aligns with the progressive refinement of tasks, where the planner determines not only the execution steps (`:plan`) but also the precise requirements and guarantees (contracts) for that specific plan.

## Security: Authenticity and Integrity via Signatures

To ensure the trustworthiness of RTFS tasks, especially in multi-agent systems or when tasks are transmitted/stored, a mechanism for verifying authenticity and integrity is crucial.

**Problem:**
- **Authenticity:** How to verify that a task component (e.g., `:plan`, `:intent`) was genuinely created by the claimed agent?
- **Integrity:** How to ensure that task components haven't been tampered with after creation by a trusted agent?

**Proposed Solution: Digital Signatures in Execution Log**
- **Agent Keys:** Each trusted agent possesses a cryptographic key pair.
- **Signing Contributions:** When an agent adds a significant entry to the `:execution-log` (e.g., generating `:plan`), it signs the relevant data artifact plus contextual information (like task ID and previous log entry hash).
- **Log Entry Extension:** Log entries would include fields like `:agent-id`, `:signature`, and potentially `:signing-key-id`.
- **Verification:** Runtimes or consuming agents can use the agent's public key to verify the signature on the log entry and the associated data, ensuring it came from the claimed agent and hasn't been altered.

**Benefits:**
- **Authenticity:** Confirms the origin of task components.
- **Integrity:** Detects any tampering after signing.
- **Non-repudiation:** Agents cannot deny their signed contributions.
- **Traceability:** Creates a verifiable, tamper-evident chain within the log.

**Considerations:**
- **Key Management:** Requires external infrastructure for managing keys.
- **Performance:** Cryptographic operations add overhead.
- **Complexity:** Adds complexity to agent implementation and runtime verification.

This mechanism integrates security directly into the append-only log structure, enhancing trust in the RTFS artifact lifecycle.

## Future Directions

- **Type System Enhancements:** Exploring gradual typing or richer specification/validation for even more robust AI-generated code.
- **Macro System:** Leveraging Clojureâ€™s macros for domain-specific extensions and code generation.
- **Advanced Error Handling:** More sophisticated mechanisms for error propagation, recovery, and logging in complex plans.
- **Resumable/Distributed Execution:** Using the immutable execution log to support pausing, resuming, or distributing task execution.

---

For foundational RTFS concepts, see `language_motivation.md`.
