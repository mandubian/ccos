;; RTFS Language Feature Test: try-catch expressions
;; Tests error handling, exception catching, and finally blocks

;; Basic try-catch
(try
  (/ 10 2)
  (catch Exception e "error-occurred"))
;; Expected: 5

;; Try-catch with error
(try
  (/ 10 0)
  (catch Exception e "division-by-zero"))
;; Expected: "division-by-zero"

;; Try-catch with multiple catch clauses
(try
  (/ 1 0)  ; This will cause a runtime error
  (catch ArithmeticException e "arithmetic-error")
  (catch RuntimeException e "runtime-error") 
  (catch Exception e "general-error"))
;; Expected: "general-error" (or appropriate error type)

;; Try-catch-finally
(try
  (+ 1 2)
  (catch Exception e "error")
  (finally (println "cleanup")))
;; Expected: 3 (with side effect)

;; Try-catch-finally with error
(try
  (/ 1 0)  ; This will cause a runtime error
  (catch Exception e "caught")
  (finally (println "always-runs")))
;; Expected: "caught" (with side effect)

;; Nested try-catch
(try
  (try
    (/ 1 0)
    (catch ArithmeticException e
      (/ 1 0)))  ; This will cause another runtime error
  (catch RuntimeException e "outer-catch"))
;; Expected: "outer-catch" or appropriate error handling

;; Try with multiple expressions
(try
  (def x 10)
  (def y 20)
  (/ x y)
  (catch Exception e "error-in-block"))
;; Expected: 0.5

;; Try-catch with binding to exception object
(try
  (/ 1 0)  ; This will cause a runtime error
  (catch Exception e (.getMessage e)))
;; Expected: error message from the exception

;; Try-catch with re-throwing (simulated with another error)
(try
  (try
    (/ 1 0)  ; This will cause a runtime error
    (catch Exception e 
      (println "Caught and causing another error")
      (/ 1 0)))  ; This will cause another runtime error
  (catch Exception e "re-caught"))
;; Expected: "re-caught" (with side effect)

;; Try-catch with different exception types
(try
  (/ 1 0)  ; This will cause a runtime error
  (catch IllegalArgumentException e "illegal-arg")
  (catch Exception e "general-exception"))
;; Expected: "general-exception"

;; Try with successful computation and unused catch
(try
  (let [result (* 6 7)]
    (if (> result 0) result (/ 1 0)))  ; This will cause a runtime error if result <= 0
  (catch Exception e "error"))
;; Expected: 42

;; Try-catch with return values from catch
(let [safe-divide (fn [a b]
                    (try
                      (/ a b)
                      (catch Exception e :division-error)))]
  [(safe-divide 10 2) (safe-divide 10 0)])
;; Expected: [5 :division-error]

;; Try-finally without catch
(try
  (* 3 4)
  (finally (println "cleanup-only")))
;; Expected: 12 (with side effect)

;; Try-catch with custom exception handling function
(let [handle-error (fn [e] {:error true :message (.getMessage e)})]
  (try
    (/ 1 0)  ; This will cause a runtime error
    (catch Exception e (handle-error e))))
;; Expected: {:error true :message "error message from exception"}

;; Propagating exceptions through multiple levels
(let [level1 (fn [] (/ 1 0))  ; This will cause a runtime error
      level2 (fn [] (try (level1) (catch Exception e (/ 1 0))))  ; This will cause another runtime error
      level3 (fn [] (try (level2) (catch Exception e "caught-at-level-3")))]
  (level3))
;; Expected: "caught-at-level-3"

;; Try-catch with resource cleanup pattern
(try
  (let [resource (open-resource)]
    (try
      (use-resource resource)
      (finally (close-resource resource))))
  (catch Exception e "resource-error"))
;; Expected: depends on implementation

;; Exception in finally block (if supported)
(try
  (try
    "normal-result"
    (finally (/ 1 0)))  ; This will cause a runtime error in finally
  (catch Exception e "caught-finally-error"))
;; Expected: "caught-finally-error"

;; Try-catch with pattern matching on exception (if supported)
(try
  (/ 1 0)  ; This will cause a runtime error
  (catch Exception e
    (match (.getMessage e)
      "error message" "pattern-matched"
      _ "pattern-not-matched")))
;; Expected: "pattern-not-matched" or appropriate pattern match

;; Edge case: Empty try block is valid only with finally
(try
  (finally (println "empty-try-finally")))
;; Expected: nil (with side effect)

;; Edge case: Catch without exception type (catch-all)
(try
  (/ 1 0)  ; This will cause a runtime error
  (catch e "caught-anything"))
;; Expected: "caught-anything" or error if syntax not supported
