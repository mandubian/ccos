# Unified Capability Synthesis: OpenAPI & MCP

## ğŸ¯ Philosophy: RTFS-First with Proper Schemas

All synthesized capabilities (OpenAPI, MCP, GraphQL, etc.) follow the **same pattern**:

1. âœ… **Introspect** the API/server to discover endpoints/tools
2. âœ… **Extract schemas** and convert to RTFS TypeExpr
3. âœ… **Generate RTFS implementation** - simple wrapper that makes the actual call
4. âœ… **Runtime validates** inputs/outputs against schemas
5. âœ… **Trivially callable** from CCOS plans and LLM-generated code

## ğŸ“Š Unified Pattern

### OpenAPI Capability
```clojure
(capability "openweather_api.get_current_weather"
  :input-schema {
    :q :string
    :units :string ;; optional
  }
  :output-schema {
    :coord { :lon :float :lat :float }
    :main { :temp :float :humidity :int }
  }
  :implementation
    (fn [input]
      (let [url (build-url-with-params input)
            api_key (call "ccos.system.get-env" "API_KEY")]
        (call "ccos.network.http-fetch" :url url ...))))
```

### MCP Capability
```clojure
(capability "mcp.github.create_issue"
  :input-schema {
    :owner :string
    :repo :string
    :title :string
    :body :string ;; optional
  }
  :output-schema {
    :number :int
    :url :string
    :state :string
  }
  :implementation
    (fn [input]
      (let [mcp_request {:jsonrpc "2.0"
                         :method "tools/call"
                         :params {:name "create_issue"
                                  :arguments input}}]
        (call "ccos.network.http-fetch"
              :method "POST"
              :url "http://localhost:3000/github-mcp"
              :body (call "ccos.data.serialize-json" mcp_request)))))
```

## ğŸš€ Usage in CCOS Plans

### The Beauty: All Capabilities Are Called The Same Way!

```clojure
;; In a CCOS plan generated by LLM from user goal:
(plan "Get weather and create GitHub issue"
  :capabilities-required [
    "openweather_api.get_current_weather"  ; OpenAPI capability
    "mcp.github.create_issue"               ; MCP capability
  ]
  :body
    (do
      ;; Call OpenAPI capability
      (let [weather ((call "openweather_api.get_current_weather") {
                      :q "London,UK"
                      :units "metric"
                    })
            
            ;; Call MCP capability  
            issue ((call "mcp.github.create_issue") {
                    :owner "myorg"
                    :repo "myrepo"
                    :title (str "Weather Alert: " (get weather :main :temp) "Â°C")
                    :body "Automated weather report"
                  })]
        
        ;; Both capabilities work identically!
        {:weather weather :issue issue})))
```

### LLM Translation Flow

```
Human Goal: "Check London weather and create a GitHub issue if temp > 30Â°C"
     â†“
LLM generates Intent Graph
     â†“
Orchestrator creates Plan
     â†“
Plan requires capabilities:
  - openweather_api.get_current_weather (OpenAPI)
  - mcp.github.create_issue (MCP)
     â†“
Runtime validates inputs against schemas
     â†“
Executes RTFS implementations:
  - OpenAPI: HTTP GET to api.openweathermap.org
  - MCP: HTTP POST (JSON-RPC) to MCP server
     â†“
Runtime validates outputs against schemas
     â†“
Returns typed results
```

## ğŸ”§ Synthesizing Capabilities

### OpenAPI â†’ RTFS Capabilities

```rust
let synthesizer = CapabilitySynthesizer::new();

let result = synthesizer
    .synthesize_from_api_introspection(
        "https://api.openweathermap.org",
        "openweather"
    )
    .await?;

// Generates: openweather_api.get_current_weather, openweather_api.get_forecast, etc.
```

### MCP Server â†’ RTFS Capabilities

```rust
let synthesizer = CapabilitySynthesizer::new();

let result = synthesizer
    .synthesize_from_mcp_introspection(
        "http://localhost:3000/github-mcp",
        "github"
    )
    .await?;

// Generates: mcp.github.create_issue, mcp.github.list_issues, etc.
```

## ğŸ“ File Structure

```
capabilities/
â”œâ”€â”€ openweather_api.get_current_weather/     # OpenAPI
â”‚   â””â”€â”€ capability.rtfs
â”œâ”€â”€ openweather_api.get_forecast/            # OpenAPI
â”‚   â””â”€â”€ capability.rtfs
â”œâ”€â”€ mcp.github.create_issue/                 # MCP
â”‚   â””â”€â”€ capability.rtfs
â””â”€â”€ mcp.github.list_issues/                  # MCP
    â””â”€â”€ capability.rtfs
```

## âœ… Benefits of Unified Approach

### 1. Consistency
- All capabilities: same calling convention
- All capabilities: same schema format
- All capabilities: same validation rules

### 2. Composability
```clojure
;; Mix OpenAPI, MCP, local capabilities seamlessly!
(do
  (let [weather ((call "openweather_api.get_current_weather") {:q "Paris"})]
       issue ((call "mcp.github.create_issue") {:title "Weather Report" ...})
       analysis ((call "local.data.analyze") {:data weather})]
    {:weather weather :issue issue :analysis analysis}))
```

### 3. LLM-Friendly
- LLM doesn't need to know if capability is OpenAPI or MCP
- Same syntax for all capability calls
- Schemas guide LLM to provide correct inputs

### 4. Runtime Safety
- All inputs validated automatically
- All outputs validated automatically
- Type errors caught before execution

### 5. Transparency
- Can inspect RTFS code to see exactly what happens
- Can modify if needed
- Can debug step-by-step

### 6. Testability
- Easy to mock (just replace the http-fetch call)
- Can unit test RTFS functions
- No need for real MCP servers in tests

## ğŸ¯ The Vision

```
User Goal (Natural Language)
         â†“
    LLM Translation
         â†“
   Intent Graph
         â†“
   CCOS Plan (RTFS)
         â†“
   Capability Calls
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â”‚
OpenAPI Caps    MCP Caps
â”‚                 â”‚
HTTP GET/POST   MCP JSON-RPC
â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
   Results (Typed)
         â†“
   Goal Achieved
```

**Key:** Whether OpenAPI or MCP, the capability is just a **typed RTFS function** that the runtime validates and executes. Simple, clean, unified! ğŸš€

## ğŸ“Š Comparison

| Feature | Old MCP (ProviderType::MCP) | New MCP (RTFS-First) |
|---------|----------------------------|----------------------|
| **Schemas** | âŒ None | âœ… Full TypeExpr |
| **Callable from plans** | âŒ Complex | âœ… Trivial `(call "mcp.tool")` |
| **Composable with OpenAPI** | âŒ Different | âœ… Same pattern |
| **LLM-friendly** | âŒ Special syntax | âœ… Same as any capability |
| **Validated** | âŒ No | âœ… Runtime validates |
| **Transparent** | âŒ Black box | âœ… See RTFS code |
| **Testable** | âŒ Needs MCP server | âœ… Can mock |

## ğŸ‰ Result

**MCP tools are now as easy to use as any other capability!**

From LLM's perspective:
```clojure
;; Call weather API (OpenAPI)
((call "openweather_api.get_current_weather") {:q "Tokyo"})

;; Call GitHub MCP (MCP server)
((call "mcp.github.create_issue") {:owner "org" :repo "repo" :title "Issue"})

;; Both work identically!
```

This is the **unified CCOS capability model** - clean, simple, powerful! ğŸ¯

