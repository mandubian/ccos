# Unified Capability Synthesis: OpenAPI & MCP

## 🎯 Philosophy: RTFS-First with Proper Schemas

All synthesized capabilities (OpenAPI, MCP, GraphQL, etc.) follow the **same pattern**:

1. ✅ **Introspect** the API/server to discover endpoints/tools
2. ✅ **Extract schemas** and convert to RTFS TypeExpr
3. ✅ **Generate RTFS implementation** - simple wrapper that makes the actual call
4. ✅ **Runtime validates** inputs/outputs against schemas
5. ✅ **Trivially callable** from CCOS plans and LLM-generated code

## 📊 Unified Pattern

### OpenAPI Capability
```clojure
(capability "openweather_api.get_current_weather"
  :input-schema {
    :q :string
    :units :string ;; optional
  }
  :output-schema {
    :coord { :lon :float :lat :float }
    :main { :temp :float :humidity :int }
  }
  :implementation
    (fn [input]
      (let [url (build-url-with-params input)
            api_key (call "ccos.system.get-env" "API_KEY")]
        (call "ccos.network.http-fetch" :url url ...))))
```

### MCP Capability
```clojure
(capability "mcp.github.create_issue"
  :input-schema {
    :owner :string
    :repo :string
    :title :string
    :body :string ;; optional
  }
  :output-schema {
    :number :int
    :url :string
    :state :string
  }
  :implementation
    (fn [input]
      (let [mcp_request {:jsonrpc "2.0"
                         :method "tools/call"
                         :params {:name "create_issue"
                                  :arguments input}}]
        (call "ccos.network.http-fetch"
              :method "POST"
              :url "http://localhost:3000/github-mcp"
              :body (call "ccos.data.serialize-json" mcp_request)))))
```

## 🚀 Usage in CCOS Plans

### The Beauty: All Capabilities Are Called The Same Way!

```clojure
;; In a CCOS plan generated by LLM from user goal:
(plan "Get weather and create GitHub issue"
  :capabilities-required [
    "openweather_api.get_current_weather"  ; OpenAPI capability
    "mcp.github.create_issue"               ; MCP capability
  ]
  :body
    (do
      ;; Call OpenAPI capability
      (let [weather ((call "openweather_api.get_current_weather") {
                      :q "London,UK"
                      :units "metric"
                    })
            
            ;; Call MCP capability  
            issue ((call "mcp.github.create_issue") {
                    :owner "myorg"
                    :repo "myrepo"
                    :title (str "Weather Alert: " (get weather :main :temp) "°C")
                    :body "Automated weather report"
                  })]
        
        ;; Both capabilities work identically!
        {:weather weather :issue issue})))
```

### LLM Translation Flow

```
Human Goal: "Check London weather and create a GitHub issue if temp > 30°C"
     ↓
LLM generates Intent Graph
     ↓
Orchestrator creates Plan
     ↓
Plan requires capabilities:
  - openweather_api.get_current_weather (OpenAPI)
  - mcp.github.create_issue (MCP)
     ↓
Runtime validates inputs against schemas
     ↓
Executes RTFS implementations:
  - OpenAPI: HTTP GET to api.openweathermap.org
  - MCP: HTTP POST (JSON-RPC) to MCP server
     ↓
Runtime validates outputs against schemas
     ↓
Returns typed results
```

## 🔧 Synthesizing Capabilities

### OpenAPI → RTFS Capabilities

```rust
let synthesizer = CapabilitySynthesizer::new();

let result = synthesizer
    .synthesize_from_api_introspection(
        "https://api.openweathermap.org",
        "openweather"
    )
    .await?;

// Generates: openweather_api.get_current_weather, openweather_api.get_forecast, etc.
```

### MCP Server → RTFS Capabilities

```rust
let synthesizer = CapabilitySynthesizer::new();

let result = synthesizer
    .synthesize_from_mcp_introspection(
        "http://localhost:3000/github-mcp",
        "github"
    )
    .await?;

// Generates: mcp.github.create_issue, mcp.github.list_issues, etc.
```

## 📁 File Structure

```
capabilities/
├── openweather_api.get_current_weather/     # OpenAPI
│   └── capability.rtfs
├── openweather_api.get_forecast/            # OpenAPI
│   └── capability.rtfs
├── mcp.github.create_issue/                 # MCP
│   └── capability.rtfs
└── mcp.github.list_issues/                  # MCP
    └── capability.rtfs
```

## ✅ Benefits of Unified Approach

### 1. Consistency
- All capabilities: same calling convention
- All capabilities: same schema format
- All capabilities: same validation rules

### 2. Composability
```clojure
;; Mix OpenAPI, MCP, local capabilities seamlessly!
(do
  (let [weather ((call "openweather_api.get_current_weather") {:q "Paris"})]
       issue ((call "mcp.github.create_issue") {:title "Weather Report" ...})
       analysis ((call "local.data.analyze") {:data weather})]
    {:weather weather :issue issue :analysis analysis}))
```

### 3. LLM-Friendly
- LLM doesn't need to know if capability is OpenAPI or MCP
- Same syntax for all capability calls
- Schemas guide LLM to provide correct inputs

### 4. Runtime Safety
- All inputs validated automatically
- All outputs validated automatically
- Type errors caught before execution

### 5. Transparency
- Can inspect RTFS code to see exactly what happens
- Can modify if needed
- Can debug step-by-step

### 6. Testability
- Easy to mock (just replace the http-fetch call)
- Can unit test RTFS functions
- No need for real MCP servers in tests

## 🎯 The Vision

```
User Goal (Natural Language)
         ↓
    LLM Translation
         ↓
   Intent Graph
         ↓
   CCOS Plan (RTFS)
         ↓
   Capability Calls
         ↓
┌────────┴────────┐
│                 │
OpenAPI Caps    MCP Caps
│                 │
HTTP GET/POST   MCP JSON-RPC
│                 │
└────────┬────────┘
         ↓
   Results (Typed)
         ↓
   Goal Achieved
```

**Key:** Whether OpenAPI or MCP, the capability is just a **typed RTFS function** that the runtime validates and executes. Simple, clean, unified! 🚀

## 📊 Comparison

| Feature | Old MCP (ProviderType::MCP) | New MCP (RTFS-First) |
|---------|----------------------------|----------------------|
| **Schemas** | ❌ None | ✅ Full TypeExpr |
| **Callable from plans** | ❌ Complex | ✅ Trivial `(call "mcp.tool")` |
| **Composable with OpenAPI** | ❌ Different | ✅ Same pattern |
| **LLM-friendly** | ❌ Special syntax | ✅ Same as any capability |
| **Validated** | ❌ No | ✅ Runtime validates |
| **Transparent** | ❌ Black box | ✅ See RTFS code |
| **Testable** | ❌ Needs MCP server | ✅ Can mock |

## 🎉 Result

**MCP tools are now as easy to use as any other capability!**

From LLM's perspective:
```clojure
;; Call weather API (OpenAPI)
((call "openweather_api.get_current_weather") {:q "Tokyo"})

;; Call GitHub MCP (MCP server)
((call "mcp.github.create_issue") {:owner "org" :repo "repo" :title "Issue"})

;; Both work identically!
```

This is the **unified CCOS capability model** - clean, simple, powerful! 🎯

