# 020 - Plan & Capability Catalog

## Overview

CCOS now maintains a unified catalog that indexes every capability and plan the
system knows about—whether it was discovered from an MCP provider, generated by
the synthesis pipeline, or authored by a user. The catalog allows operators,
tools, and the runtime itself to locate reusable assets via structured keyword
filters or semantic (embedding-based) similarity search.

The catalog service is implemented in `ccos/src/catalog/mod.rs` and exposed
through `CCOS::get_catalog()` so downstream components (CLI commands, demos,
tests) can perform queries without wiring their own data stores.

## Goals

- Provide a single source of truth for plans and capabilities.
- Support deterministic lookup (“find capability `mcp.github.github-mcp.list_issues`”) and
  fuzzy reuse (“show plans similar to *summarize GitHub issues about RTFS*”).
- Track provenance metadata (generated, discovered, user-authored) and storage
  location to understand asset lifecycle.
- Keep the catalog synchronized automatically when new capabilities or plans are
  registered so operators do not have to re-index manually.

## Data Model

Each catalog entry captures:

| Field | Description |
| ----- | ----------- |
| `id` | Capability ID or Plan ID (hash). |
| `kind` | `Capability` or `Plan`. |
| `name`, `description` | Human readable identifiers where available. |
| `source` | One of `Discovered`, `Generated`, `User`, `System`, `Unknown`. |
| `provider` | Provider hint for capabilities (e.g. `mcp`, `openapi`, `local`). |
| `tags` | Metadata keys extracted from manifests/plans. |
| `inputs` / `outputs` | Flattened schema keys for quick filtering. |
| `location` | Storage handle (`ArchiveHash` or filesystem path). |
| `capability_refs` | Capabilities required by a plan. |
| `goal` | For plans, the goal annotation when present. |
| `search_blob` | Concatenated text used for quick keyword matching. |
| `embedding` | 128-dim hashed vector used for semantic search. |

Entries are stored in an in-process `RwLock<HashMap<String, CatalogEntry>>` and a
parallel embedding index (vector of `(id, Vec<f32>)`).

## Ingestion

During `CCOS::new` we:

1. Instantiate `CatalogService` and attach it to the `CapabilityMarketplace`.
2. After bootstrapping discovered + default capabilities, we call
   `catalog.ingest_marketplace(...)` to index manifests.
3. Attach the catalog to `PlanArchive` so any subsequent `archive_plan` calls
   update the index automatically. An initial pass (`ingest_plan_archive`) picks
   up existing plans.
4. Capability lifecycle events (register, remove, update) trigger a catalog
   refresh through the marketplace’s audit pipeline.

Plans record their storage hash (if available) as the catalog location to keep a
lightweight pointer back to the archive. Capabilities currently rely on
metadata or provider heuristics for provenance; future work can extend manifests
to include explicit storage references.

## Search Modes

The catalog exposes two complementary search methods:

1. **Keyword search** (`search_keyword`) – lowercases the query and matches it
   against each entry’s `search_blob`, returning hits ordered by raw occurrence
   count. Clients can apply `CatalogFilter` (kind/source) to narrow matches.

2. **Semantic search** (`search_semantic`) – computes a simple hashed embedding
   for the query (128-dimensional bag-of-words) and scores cosine similarity
   against stored embeddings. This gives fuzzy intent matching without pulling
   in heavy vector DB dependencies. The helper normalizes vectors to avoid
   length bias.

The API returns `CatalogHit { entry, score }` so callers can decide how to rank
or mix keyword/semantic results.

## Extensibility

- Swap the current hashed embedding for a true LLM-based embedding service by
  implementing a drop-in converter for `embed_text` and storing vectors in an
  external ANN index if desired.
- Extend `CatalogFilter` with additional metadata (tags, provider, capability
  refs) as we add structured queries.
- Persist the catalog to disk (e.g., SQLite) to share state across CCOS runs.
- Surface catalog search via CLI/REST/gRPC to integrate with tooling or UIs.
- Track usage stats or execution outcomes in the catalog entry metadata to rank
  mature plans/capabilities higher.

## Interaction with Other Components

- **Capability Marketplace:** uses `set_catalog_service` and triggers re-index
  whenever lifecycle events fire.
- **Plan Archive:** pushes new plans directly to the catalog when they are
  archived.
- **Orchestrator / demos:** may query the catalog (via `CCOS::get_catalog`) to
  reuse existing solutions instead of regenerating them.

### Smart Assistant Plan Reuse

The governed smart assistant (`smart_assistant_demo.rs`) now consults the
catalog before invoking any LLM planning workflow. It assembles a search query
from the current goal, intent constraints, and clarified inputs, then performs a
semantic lookup restricted to plan entries. When a hit clears a configurable
similarity threshold (`catalog.plan_min_score`), the demo loads the archived plan
by ID, refreshes any required capabilities, and executes it immediately. Failed
executions fall back to the standard planning pipeline, ensuring reuse never
blocks fresh synthesis. This closes the loop between catalog indexing and
real-world automation examples.

- **CLI Tooling:** `cargo run --example catalog_search -- "list repository issues"`
  provides an operator-facing utility for ad-hoc catalog inspection. Flags such
  as `--plans-only`, `--capabilities-only`, and `--semantic` align with the
  catalog API to tailor result sets.

With the catalog in place we can build richer developer tooling (plan browsers,
capability explorers) and avoid recomputing orchestration artifacts whenever a
similar goal recurs.





