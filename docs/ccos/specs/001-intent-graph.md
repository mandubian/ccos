# CCOS Specification 001: Intent Graph

**Status:** Proposed
**Version:** 1.0
**Date:** 2025-07-20
**Related:** [SEP-000: System Architecture](./000-ccos-architecture.md), [SEP-003: Causal Chain](./003-causal-chain.md)

## 1. Abstract

The Intent Graph is the persistent, long-term memory of the CCOS. It represents the "why" behind all system behavior. It is a directed graph where nodes are `Intent` objects and edges represent the relationships between them.

## 2. The `Intent` Object

An `Intent` is a structured representation of a goal.

### 2.1. RTFS Representation

Intents are generated by the Arbiter in RTFS format and then parsed into structured objects for storage and execution. The canonical form is:

```clojure
(intent "deploy-web-service"
  :goal "Deploy a web service with high availability"
  :constraints {
    :availability (> uptime 0.99)
    :performance (< response-time 200)
    :cost (< monthly-cost 1000)
  }
  :preferences {
    :region "us-east-1"
    :scaling :auto
  }
  :success-criteria (and (deployed? service) 
                        (healthy? service)
                        (> (uptime service) 0.99)))
```

### 2.2. Fields

-   `intent_id` (String, UUID): A unique identifier for the intent.
-   `name` (String, Optional): A human-readable symbolic name (e.g., "deploy-production-server").
-   `original_request` (String): The initial, unprocessed natural language request from the user.
-   `rtfs_intent_source` (String): The canonical RTFS intent form as generated by the Arbiter. This is the source of truth for the intent.
-   `goal` (String): A refined, more structured statement of the goal, often generated by an LLM from the `original_request`.
-   `constraints` (Map<String, Expression>): A map of hard requirements that must be met, containing RTFS expressions for validation logic.
-   `preferences` (Map<String, Expression>): A map of soft requirements that the system should try to honor, containing RTFS expressions for preference evaluation.
-   `success_criteria` (Expression, Optional): An RTFS expression that, when evaluated, returns `true` if the intent has been successfully achieved.
-   `status` (Enum): The current lifecycle state of the intent.
    -   `Active`: The intent is new or in progress.
    -   `Completed`: The intent has been successfully fulfilled.
    -   `Failed`: The system failed to fulfill the intent.
    -   `Archived`: The intent is no longer relevant but is kept for historical analysis.
    -   `Suspended`: The intent is paused, awaiting external input or resources.
-   `created_at` / `updated_at` (Timestamp): Timestamps for lifecycle management.
-   `metadata` (Map<String, Value>): An open-ended map for additional context.

### 2.3. Graph Relationships

Intents exist within a dynamic graph structure with the following relationship fields:

-   `parent_intent` (IntentId, Optional): Parent intent in hierarchical relationships.
-   `child_intents` (Vec<IntentId>): Child intents spawned from this intent.
-   `triggered_by` (TriggerSource): What caused this intent to be created.

```clojure
;; TriggerSource enum
(enum TriggerSource
  :human-request        ; Direct human input
  :plan-execution       ; Created during plan execution  
  :system-event         ; System-triggered (monitoring, alerts)
  :intent-completion    ; Triggered by another intent completing
  :arbiter-inference)   ; Arbiter discovered need for this intent
```

### 2.4. Generation Context

To support CCOS audit and replay capabilities:

-   `generation_context` (GenerationContext): Complete context for reproducing the intent generation.

```clojure
;; NOTE: The `defstruct` keyword is a proposed enhancement for ergonomics.
;; The current RTFS 2.0 implementation uses `deftype` with map refinements
;; to achieve the same level of type safety and validation.
(deftype GenerationContext (Map Keyword Any)
  (and (has-key? :arbiter-version)
       (has-key? :generation-timestamp)
       (has-key? :input-context)))
```

## 3. Edges: Intent Relationships

Edges define how intents relate to one another, allowing for complex reasoning.

### 3.1. Edge Types

-   `DependsOn`: Intent A cannot be achieved until Intent B is completed.
-   `IsSubgoalOf`: Intent A is a necessary component for achieving the larger Intent B.
-   `ConflictsWith`: Achieving Intent A makes it impossible to achieve Intent B.
-   `Enables`: Completing Intent A provides the necessary resources or state for Intent B to begin.
-   `RelatedTo`: A generic semantic relationship, often used for clustering or finding similar past intents.
-   `TriggeredBy`: Intent A was created as a direct result of Intent B's execution or completion.
-   `Blocks`: Intent A prevents Intent B from proceeding.

### 3.2. Enhanced Edge Properties

Edges now support rich metadata and weighted relationships for advanced graph analysis:

-   `from_intent` / `to_intent` (IntentId): The two intents connected by the edge.
-   `edge_type` (Enum): The type of relationship.
-   `weight` (Float, Optional): The strength or importance of the relationship (0.0 to 1.0).
-   `metadata` (Map<String, Value>): Additional context, such as:
    -   `reason`: Explanation for the relationship
    -   `severity`: Impact level for conflicts or dependencies
    -   `confidence`: Confidence level in the inferred relationship
    -   `created_by`: Source of the relationship (arbiter, user, inference)
    -   `created_at`: Timestamp of relationship creation
    -   `expires_at`: Optional expiration for temporary relationships

### 3.3. Edge Creation and Management

```clojure
;; Basic edge creation
(create-edge :intent-a :intent-b :depends-on)

;; Weighted edge with metadata
(create-weighted-edge :intent-a :intent-b :conflicts-with
  :weight 0.8
  :metadata {
    :reason "Resource contention for database connections"
    :severity :high
    :confidence 0.95
  })

;; Edge with rich context
(create-edge-with-metadata :intent-a :intent-b :enables
  {
    :reason "Infrastructure setup enables application deployment"
    :created-by :arbiter-inference
    :confidence 0.9
    :temporary false
  })
```

## 4. Core Functionality

The Intent Graph component must provide APIs for:

-   **Storing and retrieving** intents and their relationships.
-   **Querying** the graph based on status, name, or semantic similarity of the `goal`.
-   **Traversing** the graph to find dependencies, sub-goals, or potential conflicts.
-   **Updating** the status of an intent based on the outcome of a plan execution.
-   **Inferring new edges** based on an analysis of intent content (a task often delegated to a specialized capability).
-   **Dynamic intent creation** during plan execution.
-   **Re-parsing** stored RTFS intent sources with updated parsers for version migration.

## 5. Enhanced Graph Operations

### 5.1. Advanced Graph Traversal

The Intent Graph now supports sophisticated traversal operations for complex relationship analysis:

#### **Hierarchical Traversal**
```clojure
;; Get all parent intents (intents this intent depends on)
(get-parent-intents :intent-id)

;; Get all child intents (intents that depend on this intent)
(get-child-intents :intent-id)

;; Get complete hierarchy (parents + children + siblings)
(get-intent-hierarchy :intent-id)

;; Get strongly connected intents (bidirectional relationships)
(get-strongly-connected-intents :intent-id)
```

#### **Relationship Analysis**
```clojure
;; Find intents by relationship type
(find-intents-by-relationship :intent-id :depends-on)

;; Get all edges for an intent
(get-edges-for-intent :intent-id)

;; Analyze relationship strength
(get-relationship-strength :intent-a :intent-b)
```

### 5.2. Subgraph Storage and Restore

The Intent Graph supports storing and restoring entire subgraphs in single operations, enabling efficient graph partitioning and context management:

#### **Subgraph Storage**
```clojure
;; Store entire subgraph from root intent (includes all descendants)
(store-subgraph-from-root :root-intent-id :path)

;; Store entire subgraph from child intent (includes all ancestors)
(store-subgraph-from-child :child-intent-id :path)

;; Store complete graph backup
(backup :path)
```

#### **Subgraph Restoration**
```clojure
;; Restore subgraph from file
(restore-subgraph :path)

;; Restore complete graph backup
(restore :path)
```

#### **Subgraph Data Format**
```clojure
(deftype SubgraphBackupData (Map Keyword Any)
  {
    :intents (Map IntentId StorableIntent)    ; All intents in subgraph
    :edges (Vec Edge)                         ; All edges in subgraph
    :root-intent-id IntentId                  ; Reference point
    :version String                           ; Format version
    :timestamp U64                            ; Creation timestamp
  })
```

### 5.3. Weighted Edge Analysis

Enhanced edge weighting enables sophisticated graph analysis:

```clojure
;; Create weighted edge
(create-weighted-edge :intent-a :intent-b :depends-on
  :weight 0.8)

;; Analyze relationship strength
(let [strength (get-edge-weight :intent-a :intent-b)]
  (if (> strength 0.7)
    (mark-critical-dependency :intent-a :intent-b)
    (mark-optional-dependency :intent-a :intent-b)))

;; Find critical paths
(find-critical-paths :root-intent-id)
```

### 5.4. Metadata-Enhanced Queries

Rich metadata support enables advanced querying and filtering:

```clojure
;; Find intents by metadata
(find-intents-by-metadata {
  :priority :high
  :domain :infrastructure
  :created-by :user
})

;; Query edges by metadata
(find-edges-by-metadata {
  :severity :high
  :confidence (> 0.8)
})

;; Filter by relationship context
(filter-relationships {
  :edge-type :conflicts-with
  :metadata {:severity :high}
})
```

## 6. The Living Graph: A Dynamic System

The Intent Graph is not a static data structure; it is a "living" system that evolves through interaction with the Arbiter and the user. This dynamic nature is what elevates it from a simple task list to a map of a user's strategic landscape.

### 6.1. Negotiated Goals

The Arbiter uses the graph to reason about potential conflicts or misalignments with a user's long-term goals. If a new request conflicts with a pre-existing, high-priority intent, the Arbiter can initiate a clarification dialogue with the user rather than proceeding blindly. For example: *"I see you've asked to minimize all cloud costs this month. Your new request to process this large dataset will incur significant cost. Shall I proceed anyway?"*

### 6.2. Inferred Relationships

The Arbiter can proactively analyze the graph to infer new relationships. For example, if it notices that two different intents both depend on a capability that is currently unavailable, it can create a new `BlockedBy` edge, providing deeper insight into the system's state.

### 6.3. Dynamic Intent Creation During Plan Execution

Plans can dynamically create new intents during execution. This happens when:

1. **Unexpected conditions arise** that require goal-level reasoning
2. **Complex sub-problems emerge** that warrant their own strategic planning
3. **External events trigger** new goals that relate to the current intent
4. **Resource constraints** require strategic re-planning

Example of plan-triggered intent creation:

```clojure
(plan "deploy-web-service-plan"
  (step "Create Infrastructure"
    (call :aws.create-infrastructure {...}))
  
  (step "Validate Health"
    (let [health-status (call :monitoring.check-health)]
      (if (< health-status 0.8)
        ;; Create new intent for strategic problem-solving
        (create-intent {
          :goal "Resolve infrastructure health issues"
          :parent "deploy-web-service"
          :constraints {:health-threshold 0.9}
          :triggered-by :plan-execution
          :priority :urgent
        })
        ;; Continue with normal execution
        (continue)))))
```

This "living" aspect transforms the Intent Graph from a passive record into an active, collaborative partner in achieving the user's goals.

## 7. Graph Partitioning and Context Management

### 7.1. Subgraph Isolation

The enhanced subgraph functionality enables logical partitioning of the Intent Graph for context-specific operations:

```clojure
;; Isolate infrastructure-related intents
(let [infra-subgraph (store-subgraph-from-root :infrastructure-root :infra-path)]
  ;; Work with isolated infrastructure context
  (analyze-infrastructure-dependencies infra-subgraph))

;; Create project-specific context
(let [project-subgraph (store-subgraph-from-child :project-goal :project-path)]
  ;; Manage project in isolation
  (manage-project-context project-subgraph))
```

### 7.2. Context Switching

Subgraph operations enable seamless context switching for complex multi-project scenarios:

```clojure
;; Switch to production context
(restore-subgraph :production-context-path)

;; Execute production-specific operations
(execute-production-plan)

;; Switch back to development context
(restore-subgraph :development-context-path)
```

### 7.3. Graph Merging and Conflict Resolution

Future enhancements will support merging subgraphs with conflict resolution:

```clojure
;; Merge development and production contexts
(merge-subgraphs {
  :source-1 :dev-context-path
  :source-2 :prod-context-path
  :conflict-resolution :user-prompt
  :output :merged-context-path
})
```

## 8. Performance and Scalability

### 8.1. Efficient Traversal

The enhanced graph operations use optimized algorithms for large-scale graphs:

- **Cycle Detection**: Prevents infinite recursion in complex graphs
- **Visited Tracking**: O(1) lookup for traversal optimization
- **Async Support**: Non-blocking operations for large graphs
- **Memory Management**: Efficient collection and serialization

### 8.2. Storage Optimization

Subgraph storage is optimized for performance and space efficiency:

- **Incremental Storage**: Only store changed portions of graphs
- **Compression**: Efficient serialization formats
- **Caching**: Frequently accessed subgraphs cached in memory
- **Lazy Loading**: Load subgraphs on demand

### 8.3. Query Optimization

Advanced query capabilities with performance considerations:

- **Indexed Queries**: Fast lookup by intent properties
- **Semantic Search**: Efficient similarity-based queries
- **Relationship Caching**: Cached relationship analysis results
- **Batch Operations**: Efficient bulk operations on large graphs

## 9. Intent vs Plan Steps: Architectural Decision Guidelines

A fundamental question in CCOS is when to create a new Intent versus when to create a Plan step. This decision affects the strategic vs tactical nature of the system's reasoning.

### 9.1. Create New Intent When:

- **Strategic significance**: The problem requires goal-level reasoning and constraint evaluation
- **Persistent concern**: The issue may persist beyond the current plan execution
- **User visibility**: The problem is significant enough that the user should be aware of it as a separate goal
- **Reusability**: The solution might be needed for other intents in the future
- **Complex constraints**: The problem has its own success criteria and constraints that need validation
- **External dependencies**: The solution depends on external resources or events outside the current plan's scope

### 9.2. Create Plan Step When:

- **Tactical execution**: The action is a direct implementation detail of the current intent
- **Transient operation**: The action is part of a linear sequence with no independent strategic value
- **Implementation detail**: The action is a technical requirement with no user-facing goal implications
- **Atomic operation**: The action is indivisible and doesn't warrant separate constraint validation
- **Immediate execution**: The action can and should be completed within the current plan's execution context

### 9.3. Relationship to Causal Chain

Both Intent creation and Plan steps are recorded in the Causal Chain (SEP-003), but they serve different purposes:

- **Plan steps** generate `PlanStepStarted`, `PlanStepCompleted`, `PlanStepFailed` actions in the Causal Chain
- **Intent creation** generates `IntentCreated` actions with links to the triggering plan execution
- **Intent status changes** generate `IntentStatusChanged` actions

This creates a complete audit trail showing both tactical execution (steps) and strategic evolution (intents).

### 9.4. Example: When to Choose

**Scenario**: During web service deployment, database connection fails.

**Plan Step Approach** (Tactical):
```clojure
(step "Retry Database Connection"
  (retry 3 (call :database.connect {...})))
```

**New Intent Approach** (Strategic):
```clojure
(create-intent {
  :goal "Establish reliable database connectivity"
  :constraints {:uptime (> 0.99) :latency (< 50)}
  :success-criteria (and (connected? db) (stable? db))
  :triggered-by :plan-execution
})
```

**Decision factors**:
- If this is a simple retry → Plan step
- If this requires investigating infrastructure, changing configurations, or affects other services → New intent

This distinction ensures that the Intent Graph captures strategic concerns while the Causal Chain captures all execution details.

## 10. Implementation Status

### 10.1. Completed Features

✅ **Core Intent Graph Operations**
- Intent storage and retrieval
- Basic edge creation and management
- Graph traversal and querying
- Status management and lifecycle

✅ **Enhanced Edge System**
- Weighted edges with configurable importance
- Rich metadata support for relationships
- Multiple edge types (DependsOn, IsSubgoalOf, ConflictsWith, etc.)
- Edge validation and constraint checking

✅ **Advanced Graph Traversal**
- Hierarchical relationship traversal (parents/children)
- Strongly connected component detection
- Relationship analysis and filtering
- Cycle detection and prevention

✅ **Subgraph Storage and Restore**
- Store subgraphs from root or child intents
- Complete subgraph restoration with relationship preservation
- JSON-based serialization format
- Context isolation and management

✅ **Performance Optimizations**
- Efficient traversal algorithms
- Async support for large graphs
- Memory management and caching
- Optimized storage formats

### 10.2. Future Enhancements

🔄 **Planned Features**
- Graph merging and conflict resolution
- Incremental subgraph updates
- Advanced visualization capabilities
- Real-time graph synchronization
- Machine learning-based relationship inference
- Graph analytics and metrics

### 10.3. Testing and Validation

✅ **Comprehensive Test Coverage**
- 18 Intent Graph tests covering all functionality
- Subgraph storage and restore validation
- Edge weight and metadata testing
- Performance and scalability testing
- Error handling and edge case coverage

## 11. Integration with CCOS Architecture

### 11.1. Arbiter Integration

The Intent Graph integrates with the Arbiter for intelligent goal management:

```clojure
;; Arbiter creates and manages intents
(arbiter/create-intent {
  :goal "Deploy production web service"
  :constraints {:availability (> 0.99)}
  :triggered-by :human-request
})

;; Arbiter analyzes relationships
(arbiter/analyze-conflicts :new-intent-id)

;; Arbiter infers new relationships
(arbiter/infer-relationships :intent-id)
```

### 11.2. Causal Chain Integration

All Intent Graph operations are recorded in the Causal Chain for audit and replay:

```clojure
;; Intent creation recorded in Causal Chain
(causal-chain/record-action {
  :action-type :intent-created
  :intent-id :new-intent-id
  :triggering-plan :plan-id
  :timestamp :now
})

;; Relationship changes recorded
(causal-chain/record-action {
  :action-type :relationship-created
  :from-intent :intent-a
  :to-intent :intent-b
  :edge-type :depends-on
  :weight 0.8
})
```

### 11.3. Plan Execution Integration

Plans can dynamically interact with the Intent Graph:

```clojure
(plan "dynamic-plan"
  (step "Check Intent Dependencies"
    (let [dependencies (get-parent-intents :current-intent)]
      (if (empty? dependencies)
        (continue)
        (wait-for-dependencies dependencies))))
  
  (step "Create Sub-Intent if Needed"
    (if (needs-sub-intent? :current-context)
      (create-intent {
        :goal "Handle sub-problem"
        :parent :current-intent
        :triggered-by :plan-execution
      }))))
```

This comprehensive integration ensures that the Intent Graph serves as the central nervous system of CCOS, connecting strategic goals with tactical execution while maintaining a complete audit trail of all system behavior.

### 11.4. Orchestrator → Intent Graph Status Wiring

When the Orchestrator begins executing a `Plan`, it now performs a two-phase status update on the primary associated `Intent` in the `IntentGraph`:

1. **Start**: Transition `Active → Executing` (best-effort). This marks the intent as in-flight and is useful for UIs / monitoring to distinguish queued vs running work.
2. **Completion**: After plan evaluation, transition `Executing → Completed | Failed` based on the `ExecutionResult`.

If the initial transition cannot be recorded (e.g. transient lock error), plan execution proceeds; the final terminal status update is still attempted.

Current terminal transitions implemented:
```
Active -----> Executing -----> Completed
   \                          /
  \-----> Executing -----> Failed
```
Other pre-existing statuses (Suspended, Archived) are not modified by the Orchestrator; policies may later block execution if an intent is not `Active`.

On successful execution, the `Intent.status` becomes `Completed` and `updated_at` is refreshed.
On failure, the `Intent.status` becomes `Failed` and `updated_at` is refreshed. The intent's `metadata` may contain audit entries recording the failure reason via the `IntentLifecycleManager` (future enhancement).

Implementation notes:
- Start phase uses a new `set_intent_status(intent_id, IntentStatus::Executing)` helper (best-effort, non-fatal on error).
- Completion phase calls `update_intent(intent, &ExecutionResult)` which derives `Completed` / `Failed` and persists.
- Both operations refresh `updated_at`.
- Future: emit `IntentStatusChanged` causal actions for each transition (currently implicit through plan lifecycle actions).

