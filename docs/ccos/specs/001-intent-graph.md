# CCOS Specification 001: Intent Graph

**Status:** Proposed
**Version:** 1.0
**Date:** 2025-07-20
**Related:** [SEP-000: System Architecture](./000-ccos-architecture.md), [SEP-003: Causal Chain](./003-causal-chain.md)

## 1. Abstract

The Intent Graph is the persistent, long-term memory of the CCOS. It represents the "why" behind all system behavior. It is a directed graph where nodes are `Intent` objects and edges represent the relationships between them.

## 2. The `Intent` Object

An `Intent` is a structured representation of a goal.

### 2.1. RTFS Representation

Intents are generated by the Arbiter in RTFS format and then parsed into structured objects for storage and execution. The canonical form is:

```clojure
(intent "deploy-web-service"
  :goal "Deploy a web service with high availability"
  :constraints {
    :availability (> uptime 0.99)
    :performance (< response-time 200)
    :cost (< monthly-cost 1000)
  }
  :preferences {
    :region "us-east-1"
    :scaling :auto
  }
  :success-criteria (and (deployed? service) 
                        (healthy? service)
                        (> (uptime service) 0.99)))
```

### 2.2. Fields

-   `intent_id` (String, UUID): A unique identifier for the intent.
-   `name` (String, Optional): A human-readable symbolic name (e.g., "deploy-production-server").
-   `original_request` (String): The initial, unprocessed natural language request from the user.
-   `rtfs_intent_source` (String): The canonical RTFS intent form as generated by the Arbiter. This is the source of truth for the intent.
-   `goal` (String): A refined, more structured statement of the goal, often generated by an LLM from the `original_request`.
-   `constraints` (Map<String, Expression>): A map of hard requirements that must be met, containing RTFS expressions for validation logic.
-   `preferences` (Map<String, Expression>): A map of soft requirements that the system should try to honor, containing RTFS expressions for preference evaluation.
-   `success_criteria` (Expression, Optional): An RTFS expression that, when evaluated, returns `true` if the intent has been successfully achieved.
-   `status` (Enum): The current lifecycle state of the intent.
    -   `Active`: The intent is new or in progress.
    -   `Completed`: The intent has been successfully fulfilled.
    -   `Failed`: The system failed to fulfill the intent.
    -   `Archived`: The intent is no longer relevant but is kept for historical analysis.
    -   `Suspended`: The intent is paused, awaiting external input or resources.
-   `created_at` / `updated_at` (Timestamp): Timestamps for lifecycle management.
-   `metadata` (Map<String, Value>): An open-ended map for additional context.

### 2.3. Graph Relationships

Intents exist within a dynamic graph structure with the following relationship fields:

-   `parent_intent` (IntentId, Optional): Parent intent in hierarchical relationships.
-   `child_intents` (Vec<IntentId>): Child intents spawned from this intent.
-   `triggered_by` (TriggerSource): What caused this intent to be created.

```clojure
;; TriggerSource enum
(enum TriggerSource
  :human-request        ; Direct human input
  :plan-execution       ; Created during plan execution  
  :system-event         ; System-triggered (monitoring, alerts)
  :intent-completion    ; Triggered by another intent completing
  :arbiter-inference)   ; Arbiter discovered need for this intent
```

### 2.4. Generation Context

To support CCOS audit and replay capabilities:

-   `generation_context` (GenerationContext): Complete context for reproducing the intent generation.

```clojure
;; NOTE: The `defstruct` keyword is a proposed enhancement for ergonomics.
;; The current RTFS 2.0 implementation uses `deftype` with map refinements
;; to achieve the same level of type safety and validation.
(deftype GenerationContext (Map Keyword Any)
  (and (has-key? :arbiter-version)
       (has-key? :generation-timestamp)
       (has-key? :input-context)))
```

## 3. Edges: Intent Relationships

Edges define how intents relate to one another, allowing for complex reasoning.

### 3.1. Edge Types

-   `DependsOn`: Intent A cannot be achieved until Intent B is completed.
-   `IsSubgoalOf`: Intent A is a necessary component for achieving the larger Intent B.
-   `ConflictsWith`: Achieving Intent A makes it impossible to achieve Intent B.
-   `Enables`: Completing Intent A provides the necessary resources or state for Intent B to begin.
-   `RelatedTo`: A generic semantic relationship, often used for clustering or finding similar past intents.
-   `TriggeredBy`: Intent A was created as a direct result of Intent B's execution or completion.
-   `Blocks`: Intent A prevents Intent B from proceeding.

### 3.2. Enhanced Edge Properties

Edges now support rich metadata and weighted relationships for advanced graph analysis:

-   `from_intent` / `to_intent` (IntentId): The two intents connected by the edge.
-   `edge_type` (Enum): The type of relationship.
-   `weight` (Float, Optional): The strength or importance of the relationship (0.0 to 1.0).
-   `metadata` (Map<String, Value>): Additional context, such as:
    -   `reason`: Explanation for the relationship
    -   `severity`: Impact level for conflicts or dependencies
    -   `confidence`: Confidence level in the inferred relationship
    -   `created_by`: Source of the relationship (arbiter, user, inference)
    -   `created_at`: Timestamp of relationship creation
    -   `expires_at`: Optional expiration for temporary relationships

### 3.3. Edge Creation and Management

```clojure
;; Basic edge creation
(create-edge :intent-a :intent-b :depends-on)

;; Weighted edge with metadata
(create-weighted-edge :intent-a :intent-b :conflicts-with
  :weight 0.8
  :metadata {
    :reason "Resource contention for database connections"
    :severity :high
    :confidence 0.95
  })

;; Edge with rich context
(create-edge-with-metadata :intent-a :intent-b :enables
  {
    :reason "Infrastructure setup enables application deployment"
    :created-by :arbiter-inference
    :confidence 0.9
    :temporary false
  })
```

## 4. Core Functionality

The Intent Graph component must provide APIs for:

-   **Storing and retrieving** intents and their relationships.
-   **Querying** the graph based on status, name, or semantic similarity of the `goal`.
-   **Traversing** the graph to find dependencies, sub-goals, or potential conflicts.
-   **Updating** the status of an intent based on the outcome of a plan execution.
-   **Inferring new edges** based on an analysis of intent content (a task often delegated to a specialized capability).
-   **Dynamic intent creation** during plan execution.
-   **Re-parsing** stored RTFS intent sources with updated parsers for version migration.

## 5. Enhanced Graph Operations

### 5.1. Advanced Graph Traversal

The Intent Graph now supports sophisticated traversal operations for complex relationship analysis:

#### **Hierarchical Traversal**
```clojure
;; Get all parent intents (intents this intent depends on)
(get-parent-intents :intent-id)

;; Get all child intents (intents that depend on this intent)
(get-child-intents :intent-id)

;; Get complete hierarchy (parents + children + siblings)
(get-intent-hierarchy :intent-id)

;; Get strongly connected intents (bidirectional relationships)
(get-strongly-connected-intents :intent-id)
```

#### **Relationship Analysis**
```clojure
;; Find intents by relationship type
(find-intents-by-relationship :intent-id :depends-on)

;; Get all edges for an intent
(get-edges-for-intent :intent-id)

;; Analyze relationship strength
(get-relationship-strength :intent-a :intent-b)
```

### 5.2. Subgraph Storage and Restore

The Intent Graph supports storing and restoring entire subgraphs in single operations, enabling efficient graph partitioning and context management:

#### **Subgraph Storage**
```clojure
;; Store entire subgraph from root intent (includes all descendants)
(store-subgraph-from-root :root-intent-id :path)

;; Store entire subgraph from child intent (includes all ancestors)
(store-subgraph-from-child :child-intent-id :path)

;; Store complete graph backup
(backup :path)
```

#### **Subgraph Restoration**
```clojure
;; Restore subgraph from file
(restore-subgraph :path)

;; Restore complete graph backup
(restore :path)
```

#### **Subgraph Data Format**
```clojure
(deftype SubgraphBackupData (Map Keyword Any)
  {
    :intents (Map IntentId StorableIntent)    ; All intents in subgraph
    :edges (Vec Edge)                         ; All edges in subgraph
    :root-intent-id IntentId                  ; Reference point
    :version String                           ; Format version
    :timestamp U64                            ; Creation timestamp
  })
```

### 5.3. Weighted Edge Analysis

Enhanced edge weighting enables sophisticated graph analysis:

```clojure
;; Create weighted edge
(create-weighted-edge :intent-a :intent-b :depends-on
  :weight 0.8)

;; Analyze relationship strength
(let [strength (get-edge-weight :intent-a :intent-b)]
  (if (> strength 0.7)
    (mark-critical-dependency :intent-a :intent-b)
    (mark-optional-dependency :intent-a :intent-b)))

;; Find critical paths
(find-critical-paths :root-intent-id)
```

### 5.4. Metadata-Enhanced Queries

Rich metadata support enables advanced querying and filtering:

```clojure
;; Find intents by metadata
(find-intents-by-metadata {
  :priority :high
  :domain :infrastructure
  :created-by :user
})

;; Query edges by metadata
(find-edges-by-metadata {
  :severity :high
  :confidence (> 0.8)
})

;; Filter by relationship context
(filter-relationships {
  :edge-type :conflicts-with
  :metadata {:severity :high}
})
```

## 6. The Living Graph: A Dynamic System

The Intent Graph is not a static data structure; it is a "living" system that evolves through interaction with the Arbiter and the user. This dynamic nature is what elevates it from a simple task list to a map of a user's strategic landscape.

### 6.1. Negotiated Goals

The Arbiter uses the graph to reason about potential conflicts or misalignments with a user's long-term goals. If a new request conflicts with a pre-existing, high-priority intent, the Arbiter can initiate a clarification dialogue with the user rather than proceeding blindly. For example: *"I see you've asked to minimize all cloud costs this month. Your new request to process this large dataset will incur significant cost. Shall I proceed anyway?"*

### 6.2. Inferred Relationships

The Arbiter can proactively analyze the graph to infer new relationships. For example, if it notices that two different intents both depend on a capability that is currently unavailable, it can create a new `BlockedBy` edge, providing deeper insight into the system's state.

### 6.3. Dynamic Intent Creation During Plan Execution

Plans can dynamically create new intents during execution. This happens when:

1. **Unexpected conditions arise** that require goal-level reasoning
2. **Complex sub-problems emerge** that warrant their own strategic planning
3. **External events trigger** new goals that relate to the current intent
4. **Resource constraints** require strategic re-planning

Example of plan-triggered intent creation:

```clojure
(plan "deploy-web-service-plan"
  (step "Create Infrastructure"
    (call :aws.create-infrastructure {...}))
  
  (step "Validate Health"
    (let [health-status (call :monitoring.check-health)]
      (if (< health-status 0.8)
        ;; Create new intent for strategic problem-solving
        (create-intent {
          :goal "Resolve infrastructure health issues"
          :parent "deploy-web-service"
          :constraints {:health-threshold 0.9}
          :triggered-by :plan-execution
          :priority :urgent
        })
        ;; Continue with normal execution
        (continue)))))
```

This "living" aspect transforms the Intent Graph from a passive record into an active, collaborative partner in achieving the user's goals.

## 7. Graph Partitioning and Context Management

### 7.1. Subgraph Isolation

The enhanced subgraph functionality enables logical partitioning of the Intent Graph for context-specific operations:

```clojure
;; Isolate infrastructure-related intents
(let [infra-subgraph (store-subgraph-from-root :infrastructure-root :infra-path)]
  ;; Work with isolated infrastructure context
  (analyze-infrastructure-dependencies infra-subgraph))

;; Create project-specific context
(let [project-subgraph (store-subgraph-from-child :project-goal :project-path)]
  ;; Manage project in isolation
  (manage-project-context project-subgraph))
```

### 7.2. Context Switching

Subgraph operations enable seamless context switching for complex multi-project scenarios:

```clojure
;; Switch to production context
(restore-subgraph :production-context-path)

;; Execute production-specific operations
(execute-production-plan)

;; Switch back to development context
(restore-subgraph :development-context-path)
```

### 7.3. Graph Merging and Conflict Resolution

Future enhancements will support merging subgraphs with conflict resolution:

```clojure
;; Merge development and production contexts
(merge-subgraphs {
  :source-1 :dev-context-path
  :source-2 :prod-context-path
  :conflict-resolution :user-prompt
  :output :merged-context-path
})
```

## 8. Performance and Scalability

### 8.1. Efficient Traversal

The enhanced graph operations use optimized algorithms for large-scale graphs:

- **Cycle Detection**: Prevents infinite recursion in complex graphs
- **Visited Tracking**: O(1) lookup for traversal optimization
- **Async Support**: Non-blocking operations for large graphs
- **Memory Management**: Efficient collection and serialization

### 8.2. Storage Optimization

Subgraph storage is optimized for performance and space efficiency:

- **Incremental Storage**: Only store changed portions of graphs
- **Compression**: Efficient serialization formats
- **Caching**: Frequently accessed subgraphs cached in memory
- **Lazy Loading**: Load subgraphs on demand

### 8.3. Query Optimization

Advanced query capabilities with performance considerations:

- **Indexed Queries**: Fast lookup by intent properties
- **Semantic Search**: Efficient similarity-based queries
- **Relationship Caching**: Cached relationship analysis results
- **Batch Operations**: Efficient bulk operations on large graphs

## 9. Intent vs Plan Steps: Architectural Decision Guidelines

A fundamental question in CCOS is when to create a new Intent versus when to create a Plan step. This decision affects the strategic vs tactical nature of the system's reasoning.

### 9.1. Create New Intent When:

- **Strategic significance**: The problem requires goal-level reasoning and constraint evaluation
- **Persistent concern**: The issue may persist beyond the current plan execution
- **User visibility**: The problem is significant enough that the user should be aware of it as a separate goal
- **Reusability**: The solution might be needed for other intents in the future
- **Complex constraints**: The problem has its own success criteria and constraints that need validation
- **External dependencies**: The solution depends on external resources or events outside the current plan's scope

### 9.2. Create Plan Step When:

- **Tactical execution**: The action is a direct implementation detail of the current intent
- **Transient operation**: The action is part of a linear sequence with no independent strategic value
- **Implementation detail**: The action is a technical requirement with no user-facing goal implications
- **Atomic operation**: The action is indivisible and doesn't warrant separate constraint validation
- **Immediate execution**: The action can and should be completed within the current plan's execution context

### 9.3. Relationship to Causal Chain

Both Intent creation and Plan steps are recorded in the Causal Chain (SEP-003), but they serve different purposes:

- **Plan steps** generate `PlanStepStarted`, `PlanStepCompleted`, `PlanStepFailed` actions in the Causal Chain
- **Intent creation** generates `IntentCreated` actions with links to the triggering plan execution
- **Intent status changes** generate `IntentStatusChanged` actions

This creates a complete audit trail showing both tactical execution (steps) and strategic evolution (intents).

### 9.4. Example: When to Choose

**Scenario**: During web service deployment, database connection fails.

**Plan Step Approach** (Tactical):
```clojure
(step "Retry Database Connection"
  (retry 3 (call :database.connect {...})))
```

**New Intent Approach** (Strategic):
```clojure
(create-intent {
  :goal "Establish reliable database connectivity"
  :constraints {:uptime (> 0.99) :latency (< 50)}
  :success-criteria (and (connected? db) (stable? db))
  :triggered-by :plan-execution
})
```

**Decision factors**:
- If this is a simple retry â†’ Plan step
- If this requires investigating infrastructure, changing configurations, or affects other services â†’ New intent

This distinction ensures that the Intent Graph captures strategic concerns while the Causal Chain captures all execution details.

## 10. Implementation Status

### 10.1. Completed Features

âœ… **Core Intent Graph Operations**
- Intent storage and retrieval
- Basic edge creation and management
- Graph traversal and querying
- Status management and lifecycle

âœ… **Enhanced Edge System**
- Weighted edges with configurable importance
- Rich metadata support for relationships
- Multiple edge types (DependsOn, IsSubgoalOf, ConflictsWith, etc.)
- Edge validation and constraint checking

âœ… **Advanced Graph Traversal**
- Hierarchical relationship traversal (parents/children)
- Strongly connected component detection
- Relationship analysis and filtering
- Cycle detection and prevention

âœ… **Subgraph Storage and Restore**
- Store subgraphs from root or child intents
- Complete subgraph restoration with relationship preservation
- JSON-based serialization format
- Context isolation and management

âœ… **Performance Optimizations**
- Efficient traversal algorithms
- Async support for large graphs
- Memory management and caching
- Optimized storage formats

### 10.2. Future Enhancements

ðŸ”„ **Planned Features**
- Graph merging and conflict resolution
- Incremental subgraph updates
- Advanced visualization capabilities
- Real-time graph synchronization
- Machine learning-based relationship inference
- Graph analytics and metrics

### 10.3. Testing and Validation

âœ… **Comprehensive Test Coverage**
- 18 Intent Graph tests covering all functionality
- Subgraph storage and restore validation
- Edge weight and metadata testing
- Performance and scalability testing
- Error handling and edge case coverage

## 11. Integration with CCOS Architecture

### 11.1. Arbiter Integration

The Intent Graph integrates with the Arbiter for intelligent goal management:

```clojure
;; Arbiter creates and manages intents
(arbiter/create-intent {
  :goal "Deploy production web service"
  :constraints {:availability (> 0.99)}
  :triggered-by :human-request
})

;; Arbiter analyzes relationships
(arbiter/analyze-conflicts :new-intent-id)

;; Arbiter infers new relationships
(arbiter/infer-relationships :intent-id)
```

### 11.2. Causal Chain Integration

All Intent Graph operations are recorded in the Causal Chain for audit and replay:

```clojure
;; Intent creation recorded in Causal Chain
(causal-chain/record-action {
  :action-type :intent-created
  :intent-id :new-intent-id
  :triggering-plan :plan-id
  :timestamp :now
})

;; Relationship changes recorded
(causal-chain/record-action {
  :action-type :relationship-created
  :from-intent :intent-a
  :to-intent :intent-b
  :edge-type :depends-on
  :weight 0.8
})
```

### 11.3. Plan Execution Integration

Plans can dynamically interact with the Intent Graph:

```clojure
(plan "dynamic-plan"
  (step "Check Intent Dependencies"
    (let [dependencies (get-parent-intents :current-intent)]
      (if (empty? dependencies)
        (continue)
        (wait-for-dependencies dependencies))))
  
  (step "Create Sub-Intent if Needed"
    (if (needs-sub-intent? :current-context)
      (create-intent {
        :goal "Handle sub-problem"
        :parent :current-intent
        :triggered-by :plan-execution
      }))))
```

This comprehensive integration ensures that the Intent Graph serves as the central nervous system of CCOS, connecting strategic goals with tactical execution while maintaining a complete audit trail of all system behavior.

### 11.4. Orchestrator â†’ Intent Graph Status Wiring

When the Orchestrator begins executing a `Plan`, it now performs a two-phase status update on the primary associated `Intent` in the `IntentGraph`:

1. **Start**: Transition `Active â†’ Executing` (best-effort). This marks the intent as in-flight and is useful for UIs / monitoring to distinguish queued vs running work.
2. **Completion**: After plan evaluation, transition `Executing â†’ Completed | Failed` based on the `ExecutionResult`.

If the initial transition cannot be recorded (e.g. transient lock error), plan execution proceeds; the final terminal status update is still attempted.

Current terminal transitions implemented:
```
Active -----> Executing -----> Completed
   \                          /
  \-----> Executing -----> Failed
```
Other pre-existing statuses (Suspended, Archived) are not modified by the Orchestrator; policies may later block execution if an intent is not `Active`.

On successful execution, the `Intent.status` becomes `Completed` and `updated_at` is refreshed.
On failure, the `Intent.status` becomes `Failed` and `updated_at` is refreshed. The intent's `metadata` may contain audit entries recording the failure reason via the `IntentLifecycleManager` (future enhancement).

Implementation notes:
- Start phase uses a new `set_intent_status(intent_id, IntentStatus::Executing)` helper (best-effort, non-fatal on error).
- Completion phase calls `update_intent(intent, &ExecutionResult)` which derives `Completed` / `Failed` and persists.
- Both operations refresh `updated_at`.
- Future: emit `IntentStatusChanged` causal actions for each transition (currently implicit through plan lifecycle actions).

