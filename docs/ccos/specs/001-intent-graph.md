# CCOS Specification 001: Intent Graph

**Status:** Proposed
**Version:** 1.0
**Date:** 2025-07-20
**Related:** [SEP-000: System Architecture](./000-ccos-architecture.md), [SEP-003: Causal Chain](./003-causal-chain.md)

## 1. Abstract

The Intent Graph is the persistent, long-term memory of the CCOS. It represents the "why" behind all system behavior. It is a directed graph where nodes are `Intent` objects and edges represent the relationships between them.

## 2. The `Intent` Object

An `Intent` is a structured representation of a goal.

### 2.1. RTFS Representation

Intents are generated by the Arbiter in RTFS format and then parsed into structured objects for storage and execution. The canonical form is:

```clojure
(intent "deploy-web-service"
  :goal "Deploy a web service with high availability"
  :constraints {
    :availability (> uptime 0.99)
    :performance (< response-time 200)
    :cost (< monthly-cost 1000)
  }
  :preferences {
    :region "us-east-1"
    :scaling :auto
  }
  :success-criteria (and (deployed? service) 
                        (healthy? service)
                        (> (uptime service) 0.99)))
```

### 2.2. Fields

-   `intent_id` (String, UUID): A unique identifier for the intent.
-   `name` (String, Optional): A human-readable symbolic name (e.g., "deploy-production-server").
-   `original_request` (String): The initial, unprocessed natural language request from the user.
-   `rtfs_intent_source` (String): The canonical RTFS intent form as generated by the Arbiter. This is the source of truth for the intent.
-   `goal` (String): A refined, more structured statement of the goal, often generated by an LLM from the `original_request`.
-   `constraints` (Map<String, Expression>): A map of hard requirements that must be met, containing RTFS expressions for validation logic.
-   `preferences` (Map<String, Expression>): A map of soft requirements that the system should try to honor, containing RTFS expressions for preference evaluation.
-   `success_criteria` (Expression, Optional): An RTFS expression that, when evaluated, returns `true` if the intent has been successfully achieved.
-   `status` (Enum): The current lifecycle state of the intent.
    -   `Active`: The intent is new or in progress.
    -   `Completed`: The intent has been successfully fulfilled.
    -   `Failed`: The system failed to fulfill the intent.
    -   `Archived`: The intent is no longer relevant but is kept for historical analysis.
    -   `Suspended`: The intent is paused, awaiting external input or resources.
-   `created_at` / `updated_at` (Timestamp): Timestamps for lifecycle management.
-   `metadata` (Map<String, Value>): An open-ended map for additional context.

### 2.3. Graph Relationships

Intents exist within a dynamic graph structure with the following relationship fields:

-   `parent_intent` (IntentId, Optional): Parent intent in hierarchical relationships.
-   `child_intents` (Vec<IntentId>): Child intents spawned from this intent.
-   `triggered_by` (TriggerSource): What caused this intent to be created.

```clojure
;; TriggerSource enum
(enum TriggerSource
  :human-request        ; Direct human input
  :plan-execution       ; Created during plan execution  
  :system-event         ; System-triggered (monitoring, alerts)
  :intent-completion    ; Triggered by another intent completing
  :arbiter-inference)   ; Arbiter discovered need for this intent
```

### 2.4. Generation Context

To support CCOS audit and replay capabilities:

-   `generation_context` (GenerationContext): Complete context for reproducing the intent generation.

```clojure
(defstruct GenerationContext
  :arbiter-version      ; Which Arbiter version generated this
  :generation-timestamp ; When it was generated
  :input-context       ; Additional context used in generation
  :reasoning-trace)    ; Arbiter's reasoning process (optional)
```

## 3. Edges: Intent Relationships

Edges define how intents relate to one another, allowing for complex reasoning.

### 3.1. Edge Types

-   `DependsOn`: Intent A cannot be achieved until Intent B is completed.
-   `IsSubgoalOf`: Intent A is a necessary component for achieving the larger Intent B.
-   `ConflictsWith`: Achieving Intent A makes it impossible to achieve Intent B.
-   `Enables`: Completing Intent A provides the necessary resources or state for Intent B to begin.
-   `RelatedTo`: A generic semantic relationship, often used for clustering or finding similar past intents.
-   `TriggeredBy`: Intent A was created as a direct result of Intent B's execution or completion.
-   `Blocks`: Intent A prevents Intent B from proceeding.

### 3.2. Edge Properties

-   `from_intent` / `to_intent` (IntentId): The two intents connected by the edge.
-   `edge_type` (Enum): The type of relationship.
-   `weight` (Float, Optional): The strength of the relationship.
-   `metadata` (Map<String, Value>): Additional context, such as an explanation for a conflict.

## 4. Core Functionality

The Intent Graph component must provide APIs for:

-   **Storing and retrieving** intents and their relationships.
-   **Querying** the graph based on status, name, or semantic similarity of the `goal`.
-   **Traversing** the graph to find dependencies, sub-goals, or potential conflicts.
-   **Updating** the status of an intent based on the outcome of a plan execution.
-   **Inferring new edges** based on an analysis of intent content (a task often delegated to a specialized capability).
-   **Dynamic intent creation** during plan execution.
-   **Re-parsing** stored RTFS intent sources with updated parsers for version migration.

## 5. The Living Graph: A Dynamic System

The Intent Graph is not a static data structure; it is a "living" system that evolves through interaction with the Arbiter and the user. This dynamic nature is what elevates it from a simple task list to a map of a user's strategic landscape.

### 5.1. Negotiated Goals

The Arbiter uses the graph to reason about potential conflicts or misalignments with a user's long-term goals. If a new request conflicts with a pre-existing, high-priority intent, the Arbiter can initiate a clarification dialogue with the user rather than proceeding blindly. For example: *"I see you've asked to minimize all cloud costs this month. Your new request to process this large dataset will incur significant cost. Shall I proceed anyway?"*

### 5.2. Inferred Relationships

The Arbiter can proactively analyze the graph to infer new relationships. For example, if it notices that two different intents both depend on a capability that is currently unavailable, it can create a new `BlockedBy` edge, providing deeper insight into the system's state.

### 5.3. Dynamic Intent Creation During Plan Execution

Plans can dynamically create new intents during execution. This happens when:

1. **Unexpected conditions arise** that require goal-level reasoning
2. **Complex sub-problems emerge** that warrant their own strategic planning
3. **External events trigger** new goals that relate to the current intent
4. **Resource constraints** require strategic re-planning

Example of plan-triggered intent creation:

```clojure
(plan "deploy-web-service-plan"
  (step "Create Infrastructure"
    (call :aws.create-infrastructure {...}))
  
  (step "Validate Health"
    (let [health-status (call :monitoring.check-health)]
      (if (< health-status 0.8)
        ;; Create new intent for strategic problem-solving
        (create-intent {
          :goal "Resolve infrastructure health issues"
          :parent "deploy-web-service"
          :constraints {:health-threshold 0.9}
          :triggered-by :plan-execution
          :priority :urgent
        })
        ;; Continue with normal execution
        (continue)))))
```

This "living" aspect transforms the Intent Graph from a passive record into an active, collaborative partner in achieving the user's goals.

## 6. Intent vs Plan Steps: Architectural Decision Guidelines

A fundamental question in CCOS is when to create a new Intent versus when to create a Plan step. This decision affects the strategic vs tactical nature of the system's reasoning.

### 6.1. Create New Intent When:

- **Strategic significance**: The problem requires goal-level reasoning and constraint evaluation
- **Persistent concern**: The issue may persist beyond the current plan execution
- **User visibility**: The problem is significant enough that the user should be aware of it as a separate goal
- **Reusability**: The solution might be needed for other intents in the future
- **Complex constraints**: The problem has its own success criteria and constraints that need validation
- **External dependencies**: The solution depends on external resources or events outside the current plan's scope

### 6.2. Create Plan Step When:

- **Tactical execution**: The action is a direct implementation detail of the current intent
- **Transient operation**: The action is part of a linear sequence with no independent strategic value
- **Implementation detail**: The action is a technical requirement with no user-facing goal implications
- **Atomic operation**: The action is indivisible and doesn't warrant separate constraint validation
- **Immediate execution**: The action can and should be completed within the current plan's execution context

### 6.3. Relationship to Causal Chain

Both Intent creation and Plan steps are recorded in the Causal Chain (SEP-003), but they serve different purposes:

- **Plan steps** generate `PlanStepStarted`, `PlanStepCompleted`, `PlanStepFailed` actions in the Causal Chain
- **Intent creation** generates `IntentCreated` actions with links to the triggering plan execution
- **Intent status changes** generate `IntentStatusChanged` actions

This creates a complete audit trail showing both tactical execution (steps) and strategic evolution (intents).

### 6.4. Example: When to Choose

**Scenario**: During web service deployment, database connection fails.

**Plan Step Approach** (Tactical):
```clojure
(step "Retry Database Connection"
  (retry 3 (call :database.connect {...})))
```

**New Intent Approach** (Strategic):
```clojure
(create-intent {
  :goal "Establish reliable database connectivity"
  :constraints {:uptime (> 0.99) :latency (< 50)}
  :success-criteria (and (connected? db) (stable? db))
  :triggered-by :plan-execution
})
```

**Decision factors**:
- If this is a simple retry → Plan step
- If this requires investigating infrastructure, changing configurations, or affects other services → New intent

This distinction ensures that the Intent Graph captures strategic concerns while the Causal Chain captures all execution details.
