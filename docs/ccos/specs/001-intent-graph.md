# CCOS Specification 001: Intent Graph

**Status:** Proposed
**Version:** 1.0
**Date:** 2025-07-20
**Related:** [SEP-000: System Architecture](./000-ccos-architecture.md)

## 1. Abstract

The Intent Graph is the persistent, long-term memory of the CCOS. It represents the "why" behind all system behavior. It is a directed graph where nodes are `Intent` objects and edges represent the relationships between them.

## 2. The `Intent` Object

An `Intent` is a structured representation of a goal.

### 2.1. Fields

-   `intent_id` (String, UUID): A unique identifier for the intent.
-   `name` (String, Optional): A human-readable symbolic name (e.g., "deploy-production-server").
-   `original_request` (String): The initial, unprocessed natural language request from the user.
-   `goal` (String): A refined, more structured statement of the goal, often generated by an LLM from the `original_request`.
-   `constraints` (Map<String, Value>): A map of hard requirements that must be met (e.g., `{"max_cost": 10.0, "region": "us-east-1"}`).
-   `preferences` (Map<String, Value>): A map of soft requirements that the system should try to honor (e.g., `{"priority": "speed", "provider": "aws"}`).
-   `success_criteria` (Value, Optional): An RTFS function or expression that, when evaluated, returns `true` if the intent has been successfully achieved.
-   `status` (Enum): The current lifecycle state of the intent.
    -   `Active`: The intent is new or in progress.
    -   `Completed`: The intent has been successfully fulfilled.
    -   `Failed`: The system failed to fulfill the intent.
    -   `Archived`: The intent is no longer relevant but is kept for historical analysis.
    -   `Suspended`: The intent is paused, awaiting external input or resources.
-   `created_at` / `updated_at` (Timestamp): Timestamps for lifecycle management.
-   `metadata` (Map<String, Value>): An open-ended map for additional context.

## 3. Edges: Intent Relationships

Edges define how intents relate to one another, allowing for complex reasoning.

### 3.1. Edge Types

-   `DependsOn`: Intent A cannot be achieved until Intent B is completed.
-   `IsSubgoalOf`: Intent A is a necessary component for achieving the larger Intent B.
-   `ConflictsWith`: Achieving Intent A makes it impossible to achieve Intent B.
-   `Enables`: Completing Intent A provides the necessary resources or state for Intent B to begin.
-   `RelatedTo`: A generic semantic relationship, often used for clustering or finding similar past intents.

### 3.2. Edge Properties

-   `from_intent` / `to_intent` (IntentId): The two intents connected by the edge.
-   `edge_type` (Enum): The type of relationship.
-   `weight` (Float, Optional): The strength of the relationship.
-   `metadata` (Map<String, Value>): Additional context, such as an explanation for a conflict.

## 4. Core Functionality

The Intent Graph component must provide APIs for:

-   **Storing and retrieving** intents and their relationships.
-   **Querying** the graph based on status, name, or semantic similarity of the `goal`.
-   **Traversing** the graph to find dependencies, sub-goals, or potential conflicts.
-   **Updating** the status of an intent based on the outcome of a plan execution.
-   **Inferring new edges** based on an analysis of intent content (a task often delegated to a specialized capability).

## 5. The Living Graph: A Dynamic System

The Intent Graph is not a static data structure; it is a "living" system that evolves through interaction with the Arbiter and the user. This dynamic nature is what elevates it from a simple task list to a map of a user's strategic landscape.

### 5.1. Negotiated Goals

The Arbiter uses the graph to reason about potential conflicts or misalignments with a user's long-term goals. If a new request conflicts with a pre-existing, high-priority intent, the Arbiter can initiate a clarification dialogue with the user rather than proceeding blindly. For example: *"I see you've asked to minimize all cloud costs this month. Your new request to process this large dataset will incur significant cost. Shall I proceed anyway?"*

### 5.2. Inferred Relationships

The Arbiter can proactively analyze the graph to infer new relationships. For example, if it notices that two different intents both depend on a capability that is currently unavailable, it can create a new `BlockedBy` edge, providing deeper insight into the system's state.

This "living" aspect transforms the Intent Graph from a passive record into an active, collaborative partner in achieving the user's goals.
