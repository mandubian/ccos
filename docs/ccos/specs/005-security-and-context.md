# CCOS Specification 005: Security and Context

**Status:** Proposed
**Version:** 1.0
**Date:** 2025-07-20
**Related:**
- [SEP-000: System Architecture](./000-ccos-architecture.md)
- [SEP-004: Capabilities and Delegation](./004-capabilities-and-delegation.md)

## 1. Abstract

The Security and Runtime Context is the component responsible for enforcing rules, permissions, and resource constraints on an executing plan. It ensures that a plan, which may be generated by an untrusted AI, can only perform actions that are explicitly allowed and cannot consume unbounded resources.

## 2. The `RuntimeContext` Object

The `RuntimeContext` is a data structure that is passed to the Orchestrator for every plan execution. It defines the "sandbox" in which the plan will run.

### 2.1. Fields

-   `context_id` (String, UUID): A unique identifier for this context instance.
-   `parent_context` (String, UUID, Optional): Allows for inheritance, where a child context can inherit and further restrict the policies of its parent.
-   `security_policy` (Struct): A detailed set of rules governing behavior.
-   `resource_limits` (Struct): A set of quotas for resource consumption.
-   `environment` (Map<String, Value>): A key-value store of environment-specific information (e.g., user ID, session keys) that can be safely exposed to the plan.

## 3. Security Policy

The `security_policy` defines what a plan is allowed to do.

### 3.1. Capability Permissions

This is the core of the security model. It is an explicit allow/deny list for capabilities.

-   **Allowed Capabilities**: A list of `capability_id`s (or patterns like `aws.s3.*`) that the plan is permitted to call.
-   **Denied Capabilities**: An explicit list of capabilities that are forbidden, which always overrides the allow list.
-   **Conditional Policies**: Advanced policies can include conditions, specified as RTFS expressions.
    ```json
    {
      "capability": "aws.s3.upload-file",
      "allow": true,
      "condition": "(str.ends-with? (get-in arguments [1] :key) '.txt')"
    }
    ```
    This would only allow S3 uploads for `.txt` files.

### 3.2. Network Access

-   **Allowed Hosts**: A list of domains or IP addresses the plan is allowed to connect to via network capabilities.
-   **Denied Hosts**: A list of forbidden hosts.

### 3.3. Filesystem Access

-   **Read Paths**: A list of file system paths the plan is allowed to read from.
-   **Write Paths**: A list of paths the plan is allowed to write to.

## 4. Resource Limits

The `resource_limits` prevent a rogue or inefficient plan from consuming excessive resources.

-   `max_execution_time_ms` (Integer): The maximum wall-clock time the plan is allowed to run.
-   `max_total_cost` (Float): The maximum cumulative cost (from capability SLAs) the plan is allowed to incur.
-   `max_cpu_time_ms` (Integer): The maximum CPU time.
-   `max_memory_bytes` (Integer): The maximum memory allocation.
-   `max_actions` (Integer): The maximum number of actions that can be logged to the Causal Chain, preventing infinite loops.

## 5. Orchestrator Enforcement

The Orchestrator is responsible for enforcing the policies and limits of the `RuntimeContext`.

1.  **Before Execution**: The Orchestrator can perform a static analysis of the plan to check for obvious policy violations before running it.
2.  **Before Each Step**: Before executing a step, the Orchestrator checks the current resource consumption against the limits.
3.  **Before Each `(call ...)`**:
    a. It checks the `capability_id` against the `security_policy`.
    b. If the policy is conditional, it evaluates the condition.
    c. If the call is denied, the step fails immediately with a `SecurityViolation` error, which is logged to the Causal Chain.
4.  **During Execution**: The runtime continuously monitors resource usage (time, memory) and will halt execution if any limit is exceeded.

By separating the "how" (the Plan) from the "what is allowed" (the Runtime Context), CCOS can safely execute complex, AI-generated logic in a secure and controlled environment.
