# CCOS Specification 000: System Architecture (RTFS 2.0 Edition)

**Status:** Draft for Review  
**Version:** 1.0  
**Date:** 2025-09-20  
**Audience:** Developers, Architects building AI agent systems  

## Introduction: What is CCOS?

CCOS (Cognitive-Causal Orchestration System) is a secure framework for coordinating AI agents. It treats AI as a 'mind' for reasoning (why/how) and provides a deterministic 'engine' for execution (what). At its core, CCOS embeds RTFS 2.0—a pure, immutable, reentrant language—as the substrate for plans. RTFS handles declarative logic; CCOS acts as the host, managing effects, state, and governance.

Why this design? AI-generated code can be unpredictable. RTFS's purity ensures safe evaluation; CCOS's layers add auditability, security, and adaptability. Result: Verifiable agentic systems where every action traces to an intent, without hidden mutations.

Key Benefits:
- **Safety**: No in-plan side effects—yields to governed host calls.
- **Auditability**: Immutable Causal Chain logs reasoning + execution.
- **Scalability**: Reentrant RTFS supports concurrent/federated agents.
- **Extensibility**: Capabilities via marketplace, not language bloat.

## Core Concepts

### 1. Intent: The 'Why'
Intents originate from natural language goals provided by users or systems. The Arbiter, leveraging LLM capabilities, transforms this ambiguous text into a structured, immutable RTFS Map stored in the Intent Graph. This RTFS format offers superior expressiveness over plain JSON—homoiconic s-expressions enable nested semantics, symbolic references, and easy transformation into executable plans. The Intent represents objectives with metadata like priority, constraints, and dependencies.

**Sample Intent** (JSON-like for readability; natively an RTFS Map):
```
{
  :id \"intent-123\",
  :goal \"Analyze customer sentiment in reviews\",
  :constraints {:max-cost 0.5, :privacy-level :high},
  :dependencies [\"load-reviews-from-s3\"],
  :timestamp \"2025-09-20T10:00:00Z\"
}
```
Intents evolve immutably: New versions link to priors based on outcomes, feeding back into the graph for contextual planning.

### 2. Plan: The 'How' in Pure RTFS
Building on the structured Intent, the Arbiter again employs LLM to generate RTFS source code—a declarative, pure program that the Orchestrator compiles into immutable IR. This IR consists of pure functions for data transformation and explicit yields for effects. No internal mutation: State is threaded through arguments or delegated to host capabilities (e.g., KV stores). 

In production, the workflow favors compiling RTFS source to IR once, verifying it thoroughly, and executing the cached IR multiple times for performance and security. For flexibility in dynamic or exploratory scenarios (e.g., quick iterations on new intents), the system supports on-the-fly compilation from the Arbiter's freshly generated source, preserving RTFS's deterministic purity and reentrancy.

**Sample Plan** (RTFS source generated by Arbiter; compiles to IR):
```
;; Pure data transform + yield for effect
(let [reviews (call :storage.get :s3/reviews)  ;; Yields to CCOS host
      sentiments (map (fn (review) (call :nlp.analyze review)) reviews)]  ;; Parallel yields
  (call :report.save sentiments))  ;; Yield to persist
```
Here, `(call ...)` triggers a yield: RTFS pauses execution, handing control to CCOS for resolution (e.g., via the capability marketplace), then resumes with the result. Purity ensures `map` produces new collections without altering originals—no shared state.

### Flow: From Intent to Outcome
1. **Natural Language Goal to Intent**: User inputs a goal (e.g., "Analyze reviews"); Arbiter's LLM parses and structures it into an RTFS-based Intent, adding to the Intent Graph.
2. **Intent to Plan Generation**: Arbiter uses the Intent (plus graph/chain context) to LLM-generate pure RTFS Plan source, then proposes it to the Kernel for validation.
3. **Validation**: Kernel sanitizes for injections, verifies the compiled IR and referenced capabilities, and scaffolds with safety wrappers (e.g., timeouts, error handlers).
4. **Execution Loop**:
   - Orchestrator loads the RTFS IR with initial environment from the Intent.
   - Pure computations execute locally (fast and deterministic).
   - Effectful steps yield to the Kernel for approval, resolution via GFM/DE, execution, and resumption.
   - Each phase logs to the Causal Chain (e.g., `Action {:type :CapabilityCall, :yield-request {...}}`).
5. **Adaptation**: Execution outcomes update the Intent Graph; the Arbiter analyzes failures via chain queries to generate revised plans or intents.

**Reentrant Twist**: Interruptions (e.g., quota exhaustion) capture state in the chain. Resumption loads from an `action_id`, replays pure segments deterministically, and injects host results into the RTFS environment to continue seamlessly.

## Why RTFS 2.0 Changes Everything
Pre-RTFS 2.0 assumed mutable plans (atoms for state). Now: Absolute immutability forces explicit yields, making CCOS the sole state/effect authority. Benefits:
- **Verifiability**: Compile-time IR scans for disallowed yields.
- **Reentrancy**: No hidden state—resumes are pure continuations.
- **Security**: Kernel gates every effect, chain proves compliance.

### Future: Multi-agent federation (non-breaking)
The architecture is intentionally designed to admit future multi-agent capabilities without breaking existing contracts:
- **Plan Boundary**: Plans remain pure RTFS IR artifacts. Additional agents may generate plans, but the Orchestrator and Kernel interface (compile → verify → execute with yields) stays unchanged.
- **Yield Protocol**: The `RequiresHost(effect_request)` envelope is stable. New agent types would still issue yields via the same host boundary, preserving governance and audit.
- **Delegation Logging**: The Causal Chain records all delegation decisions and outcomes. Adding an Agent Registry later only adds new action types (e.g., DelegationProposed/Approved), without changing existing ones.
- **Governance Rules**: The Constitution evaluates events as pure RTFS expressions; new agent roles become new rule scopes, not new mechanisms.

This keeps the single-agent baseline simple while ensuring multi-agent federation can be layered in incrementally.

This architecture scales to federated agents: Each sub-agent runs reentrant RTFS, sharing via chain/marketplace.

Next: Dive into Intent Graph details in 001.