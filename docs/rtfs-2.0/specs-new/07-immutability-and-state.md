# RTFS 2.0: Immutability and the State Model

Status: Active
Last updated: 2025-09-17

## 1. The Principle: Absolute Immutability

RTFS 2.0 adheres to a principle of **absolute immutability**. This is a cornerstone of the language's design, ensuring that it is safe, verifiable, and predictable.

The rules are simple and without exception:

1.  **All Values are Immutable**: Once a value (number, string, list, map, vector, etc.) is created, it can never be changed. Functions that appear to "modify" a collection, such as `assoc` or `concat`, always return a *new* collection. The original is untouched.
2.  **All Bindings are Immutable**: When a symbol is bound to a value using `let` or a function parameter, that binding is fixed for its entire lexical scope. There is no mechanism to re-assign the symbol to a new value.

This means that the RTFS core language has **no concept of internal mutation or side effects**.

## 2. Rationale: Why No `atom` or `set!`?

Previous experimental versions of RTFS included primitives for mutation (`atom`, `swap!`, `set!`), which are common in other LISPs like Clojure. In RTFS 2.0, these have been deliberately and completely removed. The rationale is critical to understanding the language's philosophy.

### 2.1. Upholding the Pure Core Philosophy

The primary goal of RTFS 2.0 is to be a pure, verifiable engine for data transformation. Internal mutation primitives, even if they don't touch the external world, violate this purity. They introduce hidden state, make evaluation order significant, and break referential transparency (the guarantee that a function with the same inputs always produces the same output). By removing them, the language becomes dramatically simpler to reason about.

### 2.2. Security and Predictability for AI-Generated Code

A primary use case for RTFS is to execute code generated by AI models (LLMs). In this context, safety and predictability are not just desirable; they are a necessity.

-   **Reduced Attack Surface**: A language with no mutation offers fewer ways for generated code to behave unexpectedly or maliciously. An LLM cannot generate code that corrupts a shared state object because no such object can exist.
-   **Simplified Verification**: Verifying the correctness of AI-generated code is a major challenge. A purely functional program is far easier to analyze, test, and formally verify than one with mutable state. The behavior of the code depends only on its inputs, not on a hidden history of mutations.

### 2.3. Forcing Good Design: State Belongs in the Host

Mutation is often used as a convenient shortcut for managing state. By removing this shortcut, RTFS 2.0 forces a more robust and explicit model of state management that aligns perfectly with the Host boundary.

If a process requires state, that state is not a hidden detail *within* the RTFS execution. **State is data**, and it should be managed explicitly.

## 3. The RTFS Model for State: Threading Through the Host

The "RTFS way" to manage state is to thread it through functions and, for longer-lived state, through the Host itself.

### 3.1. State in Pure Functions

A pure function that needs to update state must take the current state as an argument and return the new state as part of its result.

```rtfs
;; A pure function that "updates" a game character's state
(def take-turn (fn (character current-action)
  ;; ... logic that calculates the next state
  (let [new-character (assoc character :hp (- (get character :hp) 10))]
    ;; Returns the new state
    new-character)))

;; Usage
(let [char1 {:hp 100 :name "Gandalf"}]
  (let [char2 (take-turn char1 :magic-missile)]
    ;; char1 is unchanged. char2 is the new state.
    char2)) ;; => {:hp 90 :name "Gandalf"}
```

### 3.2. State Managed by the Host

For state that needs to persist across multiple, separate RTFS executions, the Host is the sole manager.

This creates a clean, auditable loop:

1.  **Host**: Invokes the RTFS engine with the current state as an argument.
    -   `rtfs.execute('(do-something {:state "A"})')`
2.  **RTFS**: The RTFS code executes its pure logic. If it needs to perform an action and update the state, it yields to the host. The return value contains the desired new state.
    -   `=> Complete({:result "Done", :new-state "B"})`
3.  **Host**: Receives the result. It securely stores the `:new-state`.
4.  **Host**: For the next operation, it repeats the cycle, injecting the new state.
    -   `rtfs.execute('(do-next-thing {:state "B"})')`

This pattern makes state management explicit, observable, and controllable by the Host's governance rules. The RTFS engine remains a stateless, predictable calculator.

## 4. Obsolete and Removed Constructs

The following constructs related to mutation are **not part of the RTFS 2.0 language** and will cause a parse or evaluation error.

-   `set!`
-   `atom`
-   `deref` (and the `@` reader macro)
-   `reset!`
-   `swap!`

Any logic that requires these concepts must be refactored to use the pure, state-passing model described above.
